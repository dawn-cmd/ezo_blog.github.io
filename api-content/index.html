{"posts":[{"title":"Codeforces Round #661 Div3 retrospect","content":"First, here is my score and rate: A. Remove Smallest Problem You are given the array a consisting of n positive (greater than zero) integers. In one move, you can choose two indices i and j (i≠j) such that the absolute difference between ai and aj is no more than one (|ai−aj|≤1) and remove the smallest of these two elements. If two elements are equal, you can remove any of them (but exactly one). Your task is to find if it is possible to obtain the array consisting of only one element using several (possibly, zero) such moves or not. You have to answer t independent test cases. Input The first line of the input contains one integer t (1≤t≤1000) — the number of test cases. Then t test cases follow. The first line of the test case contains one integer n (1≤n≤50) — the length of a. The second line of the test case contains n integers a1,a2,…,an (1≤ai≤100), where ai is the i-th element of a. Ouput For each test case, print the answer: &quot;YES&quot; if it is possible to obtain the array consisting of only one element using several (possibly, zero) moves described in the problem statement, or &quot;NO&quot; otherwise. Limits time limit per test1 second memory limit per test256 megabytes## First, here is my score and rate: A. Remove Smallest Problem You are given the array a consisting of n positive (greater than zero) integers. In one move, you can choose two indices i and j (i≠j) such that the absolute difference between ai and aj is no more than one (|ai−aj|≤1) and remove the smallest of these two elements. If two elements are equal, you can remove any of them (but exactly one). Your task is to find if it is possible to obtain the array consisting of only one element using several (possibly, zero) such moves or not. You have to answer t independent test cases. Input The first line of the input contains one integer t (1≤t≤1000) — the number of test cases. Then t test cases follow. The first line of the test case contains one integer n (1≤n≤50) — the length of a. The second line of the test case contains n integers a1,a2,…,an (1≤ai≤100), where ai is the i-th element of a. Ouput For each test case, print the answer: &quot;YES&quot; if it is possible to obtain the array consisting of only one element using several (possibly, zero) moves described in the problem statement, or &quot;NO&quot; otherwise. Limits time limit per test1 second memory limit per test256 megabytes ","link":"https://dawn-cmd.github.io/BKt7ppc1X/"},{"title":"Kick Start 2020 Round D T2 Alien Piano Analysis","content":"Official Link Here Problem An alien has just landed on Earth, and really likes our music. Lucky for us. The alien would like to bring home its favorite human songs, but it only has a very strange instrument to do it with: a piano with just 4 keys of different pitches. The alien converts a song by writing it down as a series of keys on the alien piano. Obviously, this piano will not be able to convert our songs completely, as our songs tend to have many more than 4 pitches. The alien will settle for converting our songs with the following rules instead: The first note in our song can be converted to any key on the alien piano. For every note after, if its pitch is higher than the previous note, it should be converted into a higher-pitched key than the previous note's conversion; if lower, it should be converted into a lower-pitched key than the previous note's conversion; if exactly identical, it should be converted into the same key as the previous note's conversion. Note: two notes with the same pitch do not need to be converted into the same key if they are not adjacent. What the alien wants to know is: how often will it have to break its rules when converting a particular song? To elaborate, let us describe one of our songs as having K notes. The first note we describe as &quot;note 1&quot;, the second note &quot;note 2&quot;, and the last note &quot;note K.&quot; So note 2 comes immediately after note 1. Now if note 2 is lower than note 1 in our version of the song, yet converted to an equally-pitched or lower-pitched key (relative to note 2's conversion) in the alien's version of the song, then we consider that a single rule break. For each test case, return the minimum amount of times the alien must necessarily break one of its rules in converting that song. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case consists of two lines. The first line consists of a single integer, K. The second line consists of K space-separated integers, A1, A2 ... AK, where Ai refers to the pitch of the i-th note for this test case. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum number of times that particular test case will require the alien to break its own rules during the conversion process. Limits Memory limit: 1GB. 1 ≤ T ≤ 100. 1 ≤ Ai ≤ 106. Test set 1 Time limit: 20 seconds. 1 ≤ K ≤ 10. Test set 2 Time limit: 40 seconds. 1 ≤ K ≤ 104. Analysis O(4^K) Solution: We can generate all possible conversions and choose the one with the smallest number of violations. To a fixed K, there exist 4^K solutions, so the time complexity is O(4^K). O(K) Solution1: When I was finishing this problem, I first came up with DP--Dynamic programming. We can consider dp[i][j] as the smallest number of violation when you choose conversion j at the position of i. So dp[i][j] equals to min(dp[i-1][k]+(violate the rule?1:0)). Because we just need one layer of loop, so the time complexity is O(K). O(K) Solution2: We can interpret the problem through this way: record the number of ascending or descending substrings which is longer than 4. We just need to make sure each element is ergodic. Code of O(K) Solution 1: #include&lt;bits/stdc++.h&gt; using namespace std; int n; int a[10010]; int dp[10010][6]; void initialization(){ memset(a,0,sizeof a); memset(dp,0,sizeof dp); return; } int main(){ int T; cin&gt;&gt;T; for(int cas=1;cas&lt;=T;++cas){ initialization(); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;a[i]; if(i!=1&amp;&amp;a[i]==a[i-1]){ --i; --n; } } for(int i=1;i&lt;=4;++i){ dp[1][i]=0; } for(int i=2;i&lt;=n;++i){ for(int j=1;j&lt;=4;++j){ dp[i][j]=2147483647; if(a[i]&gt;a[i-1]){ for(int k=1;k&lt;=4;++k){ if(k&lt;j){ dp[i][j]=min(dp[i][j],dp[i-1][k]); } else{ dp[i][j]=min(dp[i][j],dp[i-1][k]+1); } } } else{ for(int k=1;k&lt;=4;++k){ if(k&gt;j){ dp[i][j]=min(dp[i][j],dp[i-1][k]); } else{ dp[i][j]=min(dp[i][j],dp[i-1][k]+1); } } } } } int ans=2147483647; for(int i=1;i&lt;=4;++i){ ans=min(ans,dp[n][i]); } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } Code of O(K) Solution 2: #include&lt;bits/stdc++.h&gt; using namespace std; int n; int main(){ int T; cin&gt;&gt;T; for(int cas=1;cas&lt;=T;++cas){ cin&gt;&gt;n; int now; int pre; int ans=0; int upcnt=0; int downcnt=0; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;now; if(i==1||now==pre){ pre=now; continue; } if(now&gt;pre){ upcnt++; downcnt=0; } else{ upcnt=0; downcnt++; } if(upcnt&gt;3||downcnt&gt;3){ ++ans; upcnt=0; downcnt=0; } pre=now; } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } ","link":"https://dawn-cmd.github.io/cJ22lJu5P/"},{"title":"Kick Start 2020 Round D T1 Record Breaker Analysis","content":"Official Link Here Problem Isyana is given the number of visitors at her local theme park on N consecutive days. The number of visitors on the i-th day is Vi. A day is record breaking if it satisfies both of the following conditions: The number of visitors on the day is strictly larger than the number of visitors on each of the previous days. Either it is the last day, or the number of visitors on the day is strictly larger than the number of visitors on the following day. Note that the very first day could be a record breaking day! Please help Isyana find out the number of record breaking days. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. The second line contains N integers. The i-th integer is Vi. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the number of record breaking days. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 ≤ T ≤ 100. 0 ≤ Vi ≤ 2 × 105. Test set 1 1 ≤ N ≤ 1000. Test set 2 1 ≤ N ≤ 2 × 105 for at most 10 test cases. For the remaining cases, 1 ≤ N ≤ 1000. Sample Input 4 8 1 2 0 7 2 0 2 0 6 4 8 15 16 23 42 9 3 1 4 1 5 9 2 6 5 6 9 9 9 9 9 9 Output Case #1: 2 Case #2: 1 Case #3: 3 Case #4: 0 Explanation In Sample Case #1, the bold and underlined numbers in the following represent the record breaking days: 1 2 0 7 2 0 2 0. In Sample Case #2, only the last day is a record breaking day. In Sample Case #3, the first, the third, and the sixth days are record breaking days. In Sample Case #4, there is no record breaking day. Analysis O(n^2) Solution: To every V[i], we can check all the previous numbers to verify whether it breaks the record or not. So it is an O(n^2) Solution, it is enough to pass the time set one. O(n) Solution: We can list all v[i] and use a varition RECORD to record the existed record(???). When a v[i] break the record, it satisfy the first requirement, thus, we just need to check whether it satisfies the second requirement or not. The total time complexity of the solution is O(n), it is enough to pass the time set two. Code of the best solution #include&lt;bits/stdc++.h&gt; using namespace std; int n; int v[200010]; int main(){ int T; cin&gt;&gt;T; for(int cas=1;cas&lt;=T;++cas){ cin&gt;&gt;n; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;v[i]; } int maxn=-1; int ans=0; for(int i=1;i&lt;=n;++i){ if(v[i]&gt;maxn){ if(i==n||v[i]&gt;v[i+1]){ ++ans; } maxn=v[i]; } } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } ","link":"https://dawn-cmd.github.io/76NaE9Spv/"},{"title":"Kick Start 2020 Round C T3 Perfect Subarray Analysis","content":"Problem Cristobal has an array of N (possibly negative) integers. The i-th integer in his array is Ai. A contiguous non-empty subarray of Cristobal's array is perfect if its total sum is a perfect square. A perfect square is a number that is the product of a non-negative integer with itself. For example, the first five perfect squares are 0, 1, 4, 9 and 16. How many subarrays are perfect? Two subarrays are different if they start or end at different indices in the array, even if the subarrays contain the same values in the same order. Input The first line of the input gives the number of test cases, T. T test cases follow. The first line of each test case contains the integer N. The second line contains N integers describing Cristobal's array. The i-th integer is Ai. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the number of perfect subarrays. Limits Memory limit: 1GB. 1 ≤ T ≤ 100. -100 ≤ Ai ≤ 100, for all i. Test set 1 Time limit: 20 seconds. 1 ≤ N ≤ 1000. Test set 2 Time limit: 30 seconds. For up to 5 cases, 1 ≤ N ≤ 105. For the remaining cases, 1 ≤ N ≤ 1000. Sample Input 3 3 2 2 6 5 30 30 9 1 30 4 4 0 0 16 Output Case #1: 1 Case #2: 3 Case #3: 9 Explanation In sample case #1, there is one perfect subarray: [2 2] whose sum is 22. In sample case #2, there are three perfect subarrays: [9], whose total sum is 32. [1], whose total sum is 12. [30 30 9 1 30], whose total sum is 102. In sample case #3, there are nine perfect subarrays: [4], whose total sum is 22. [4 0], whose total sum is 22. [4 0 0], whose total sum is 22. [0], whose total sum is 02. [0 0], whose total sum is 02. [0 0 16], whose total sum is 42. [0], whose total sum is 02. [0 16], whose total sum is 42. [16], whose total sum is 42. Note We do not recommend using interpreted/slower languages for the test set 2 of this problem. Anaylsis O(n^2) Solution: Easily, we only need to check every subarray in it. In an n-length array, there exist n*(n+1)/2 subarrays. So the time complexity of this algorithm is O(n^2). O(nsqrt(1e7) to nlogn*sqrt(1e7)) Solution: First, we use sum[] to record the prefix sum of a[]. So the problem becomes: how many sum[i]-sum[j-1]=x^2(i&gt;=j &amp;&amp; x is an integer). This formula equals to sum[j-1]=sum[i]-x^2. So, all we need to do is to enumerate all possible x and check how many j meet the requirement. To implement it, we can use a hash table to record the number of exist sum[j], which has a O(1) time complexity. This algorithm's time complexity can be accepted narrowly. Code of the best Solution #include&lt;bits/stdc++.h&gt; #define BASE 15000000 #define LL long long using namespace std; int n; int a[100010]; LL h[70000010]; int main(){ int T; cin&gt;&gt;T; for(int cas=1;cas&lt;=T;++cas){ memset(h,0,sizeof h); LL ans=0; cin&gt;&gt;n; h[BASE]=1; a[0]=BASE; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;a[i]; a[i]+=a[i-1]; } int minn=BASE; for(int i=1;i&lt;=n;++i){ for(int j=0;j*j&lt;=10000000;++j){ if(a[i]-j*j&lt;minn){ break; } ans+=h[a[i]-j*j]; } minn=min(a[i],minn); h[a[i]]++; } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } P.S. If you use C++ to solve this problem, do not use map, which will add a logn to your time complexity. You should use long long to save the answer. Do not use Python. ","link":"https://dawn-cmd.github.io/r6whUkCyg/"},{"title":"Topological Sort","content":"Introduction Many times, the sort of our works are fixed in some degrees: you may be able to change the order of washing your face and brushing your teeth, but you cannot change the order of getting out and dressing up. Yes, many things have a comparative order, which means that they are neither totally fixed nor sheer random. So it is very difficult to determine the sort by normal ways, as a result, here comes the Topological Sort. Defination Topological Sort is linear sort of a Directed Acyclic Graph(DAG). The DAG is often used to represent a complicated dependancy relationship. Implementation We can use either DFS or BFS to solve it. But the core mechanisms of these two algorithms are same -- find the 0-in-degree vertaxs, add them to the answer, eliminate all the edges from it, and then repeats it until there is no 0-in-degree vertaxs. DFS code: #include&lt;bits/stdc++.h&gt; using namespace std; int n; int m; vector&lt;int&gt; mp[200]; int incnt[200]; vector&lt;int&gt; ans; void Topo(int now){ ans.push_back(now); for(int i=0;i&lt;mp[now].size();++i){ int y=mp[now][i]; --incnt[y]; if(incnt[y]==0){ Topo(y); } } return; } int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;++i){ int x; int y; cin&gt;&gt;x&gt;&gt;y; mp[x].push_back(y); incnt[y]++; } for(int i=1;i&lt;=n;++i){ mp[0].push_back(i); incnt[i]++; } Topo(0); for(int i=1;i&lt;ans.size();++i){ cout&lt;&lt;ans[i]&lt;&lt;' '; } cout&lt;&lt;endl; return 0; } BFS code: #include&lt;bits/stdc++.h&gt; using namespace std; int n; int m; vector&lt;int&gt; mp[200]; vector&lt;int&gt; ans; int incnt[200]; void Topo(){ queue&lt;int&gt; q; q.push(0); while(!q.empty()){ int x=q.front(); ans.push_back(x); q.pop(); int y; for(int i=0;i&lt;mp[x].size();++i){ y=mp[x][i]; incnt[y]--; if(incnt[y]==0){ q.push(y); } } } return; } int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;++i){ int x; int y; cin&gt;&gt;x&gt;&gt;y; mp[x].push_back(y); incnt[y]++; } for(int i=1;i&lt;=n;++i){ mp[0].push_back(i); incnt[i]++; } Topo(); for(int i=1;i&lt;ans.size();++i){ cout&lt;&lt;ans[i]&lt;&lt;' '; } cout&lt;&lt;endl; return 0; } In the end Topological sort is one of the basic graph algorithms. I will appreciate you if you think this blog is beneficial. Moreover, this problem can serve as a good case in point. ","link":"https://dawn-cmd.github.io/o_E2mKnup/"},{"title":"Kick Start 2020 Round C T1 Countdown Analysis","content":"Official link Here Problem Avery has an array of N positive integers. The i-th integer of the array is Ai. A contiguous subarray is an m-countdown if it is of length m and contains the integers m, m-1, m-2, ..., 2, 1 in that order. For example, [3, 2, 1] is a 3-countdown. Can you help Avery count the number of K-countdowns in her array? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integers N and K. The second line contains N integers. The i-th integer is Ai. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the number of K-countdowns in her array. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 ≤ T ≤ 100. 2 ≤ K ≤ N. 1 ≤ Ai ≤ 2 × 10^5, for all i. Test set 1 2 ≤ N ≤ 1000. Test set 2 2 ≤ N ≤ 2 × 10^5 for at most 10 test cases. For the remaining cases, 2 ≤ N ≤ 1000. Analysis O(nk) solution:for each A[i to i+k], we can check it whether meets the requirement in the problem or not. O(n) solution: We can set a variation &quot;head&quot;. At first, head equals to k. If A[i] equals to head, head minus one, otherwise reset head. When head equals to 0, we find a countdown, and then we need to add it to the answer and reset head. Code of the best solution #include&lt;bits/stdc++.h&gt; using namespace std; int n; int k; int main(){ int T; cin&gt;&gt;T; for(int P=1;P&lt;=T;++P){ cin&gt;&gt;n&gt;&gt;k; int head=k; int ans=0; for(int i=1;i&lt;=n;++i){ int now; cin&gt;&gt;now; if(now==head){ --head; } else{ head=now==k?k-1:k; } if(head==0){ ++ans; head=k; } } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;P&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } P.S. When you reset head, checking adjacent number is necessary.&gt;line 19 ","link":"https://dawn-cmd.github.io/kick-start-2020-round-c-t1-countdown-analysis/"},{"title":"Kick Start 2020 Round C T2 Stable_Wall Analysis","content":" Before the passage I think the data of this problem should be strengthened. Because of the weak data, many people can solve the problem via a very stupid way(me). the details will be furnished in the following passage. However, the ratio of people who passed the problem is lower than the one in other contemporary rounds, it is unbelievable. Official link Here Problem Apollo is playing a game involving polyominos. A polyomino is a shape made by joining together one or more squares edge to edge to form a single connected shape. The game involves combining N polyominos into a single rectangular shape without any holes. Each polyomino is labeled with a unique character from A to Z. Apollo has finished the game and created a rectangular wall containing R rows and C columns. He took a picture and sent it to his friend Selene. Selene likes pictures of walls, but she likes them even more if they are stable walls. A wall is stable if it can be created by adding polyominos one at a time to the wall so that each polyomino is always supported. A polyomino is supported if each of its squares is either on the ground, or has another square below it. Apollo would like to check if his wall is stable and if it is, prove that fact to Selene by telling her the order in which he added the polyominos. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers R and C. Then, R lines follow, describing the wall from top to bottom. Each line contains a string of C uppercase characters from A to Z, describing that row of the wall. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is a string of N uppercase characters, describing the order in which he built them. If there is more than one such order, output any of them. If the wall is not stable, output -1 instead. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 ≤ T ≤ 100. 1 ≤ R ≤ 30. 1 ≤ C ≤ 30. No two polyominos will be labeled with the same letter. The input is guaranteed to be valid according to the rules described in the statement. Test set 1 1 ≤ N ≤ 5. Test set 2 1 ≤ N ≤ 26. Sample Input 4 4 6 ZOAAMM ZOAOMM ZOOOOM ZZZZOM 4 4 XXOO XFFO XFXO XXXO 5 3 XXX XPX XXX XJX XXX 3 10 AAABBCCDDE AABBCCDDEE AABBCCDDEE Output Case #1: ZOAM Case #2: -1 Case #3: -1 Case #4: EDCBA Explainatoin In sample case #1, note that ZOMA is another possible answer. In sample case #2 and sample case #3, the wall is not stable, so the answer is -1. In sample case #4, the only possible answer is EDCBA. Analysis O(n!) solution:We can list all the possible order that the polyominos being set in and then check them one by one. O(n to n!) solution:this is the stupid wayWhen I was solving the problem, I used DFS technique(Deep-First-Search) to address it. Specifically, I imitated the process of setting polyomino: I determined which polyomino I should put one by one, when there exist problems, we back to the previous step and try another way. Because N is specially small, this solution can be accepted narrowly. O(R * C) solution:So this is the best solution. Literally, when a polyomino is totally or partly above another polyomino, the upper one should be set after the lower one restrictly. When it happpens, we can consider these two polyominos as two vertexs, and build an edge directed from the lower one to the upper one. We proceed all the polyominos by this way, in the end, we can get a graph. All we need to do is to find a topological sort of the graph. About topological sort, if you do not know it very well, this passage may help you. Code of my solution #include&lt;bits/stdc++.h&gt; using namespace std; int T; int r; int c; string ans; string mp[31]; string lit; map&lt;char,int&gt; h; bool check(){ for(int i=1;i&lt;r;++i){ for(int j=0;j&lt;c;++j){ if(h[mp[i][j]]==0&amp;&amp;h[mp[i-1][j]]==1){ return 0; } } } return 1; } void dfs(string now){ if(now.length()==lit.length()){ ans=now; return; } if(ans!=&quot;-1&quot;){ return; } for(int i=0;i&lt;lit.length();++i){ if(h[lit[i]]==1){ continue; } h[lit[i]]=1; if(check()){ dfs(now+lit[i]); } h[lit[i]]=0; } } int main(){ cin&gt;&gt;T; for(int P=1;P&lt;=T;++P){ cin&gt;&gt;r&gt;&gt;c; lit=&quot;&quot;; h.erase(h.begin(),h.end()); for(int i=0;i&lt;r;++i){ cin&gt;&gt;mp[i]; for(int j=0;j&lt;c;++j){ if(h[mp[i][j]]==0){ h[mp[i][j]]=1; lit+=mp[i][j]; } } } h.erase(h.begin(),h.end()); ans=&quot;-1&quot;; dfs(&quot;&quot;); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;P&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } Code of the best solution #include&lt;bits/stdc++.h&gt; using namespace std; int r; int c; string mp[1000]; vector&lt;int&gt; graph[1000]; int incnt[1000]; int n; string ans; map&lt;char,int&gt; h; void topo(){ queue&lt;int&gt; q; for(int i=1;i&lt;=30;++i){ if(incnt[i]==0&amp;&amp;h[(char)(i+'A'-1)]){ q.push(i); } } while(!q.empty()){ int x=q.front(); ans+=(char)(x+'A'-1); q.pop(); for(int i=0;i&lt;graph[x].size();++i){ int y=graph[x][i]; incnt[y]--; if(incnt[y]==0){ q.push(y); } } } return; } int main(){ int T; cin&gt;&gt;T; for(int P=1;P&lt;=T;++P){ cin&gt;&gt;r&gt;&gt;c; n=0; h.erase(h.begin(),h.end()); for(int i=0;i&lt;r;++i){ cin&gt;&gt;mp[i]; for(int j=0;j&lt;c;++j){ if(h[mp[i][j]]==0){ h[mp[i][j]]=1; ++n; } } } memset(incnt,0,sizeof incnt); map&lt;pair&lt;int,int&gt;,int&gt; he; for(int i=1;i&lt;=30;++i){ graph[i].clear(); } for(int i=1;i&lt;r;++i){ for(int j=0;j&lt;c;++j){ if(mp[i][j]!=mp[i-1][j]){ int x=mp[i][j]-'A'+1; int y=mp[i-1][j]-'A'+1; if(he[make_pair(x,y)]==0){ graph[x].push_back(y); he[make_pair(x,y)]=1; ++incnt[y]; } } } } ans=&quot;&quot;; topo(); if(ans.length()&lt;n){ cout&lt;&lt;&quot;Case #&quot;&lt;&lt;P&lt;&lt;&quot;: &quot;&lt;&lt;&quot;-1&quot;&lt;&lt;endl; } else{ cout&lt;&lt;&quot;Case #&quot;&lt;&lt;P&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } } return 0; } ","link":"https://dawn-cmd.github.io/kick-start-2020-round-c-t2-stable_wall-analysis/"}]}