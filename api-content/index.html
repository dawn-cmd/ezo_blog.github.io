{"posts":[{"title":"Edmonds-Karp Algorithm","content":"Introduction In this passage, I will show one of the most classic problems on graph: the network flow problem. The graph is made by several vertexs and edges which have directions and capacities. There exist a source vertex and a sink vertex in the graph. And the problem is to calculate the maximum flow from source vertex to the sink vertex. If you think it is hard to understand, you can consider it as a water pipe system under the ground: In the system, each pipe has a capacity and direction. And the question is to calculate how much water can flow from the source to the sink in a minute. Prerequisite: Build the Graph In most cases, this part is not mentioned in many other kinds of introduction of other graph algorithms. Because most of them just need a effective way to check the whole graph but do not need to concern the order. Nevertheless, in the network flow problems, we need to attach two antiparallel edges to each other.(I will explain the reason later in the passage.) So I recommend using array to imitate static list but not other data structure. If you use this structure and add a pair of antiparallel edge, you will find their ids in the array are adjacent. Suppose one of edges' id is x. Then, its antiparallel edge's id is x^1. The benefit enables the computer to &quot;regret&quot; when they choose a wrong answer. Step1: Find Augmenting Path Before we formally start coding, let me explain the main idea briefly: Find a augmenting path, add the minimum capacity to the answer, and repeat it until there is no augmenting path. So, what's the augmenting path? Generally speaking, an augmenting path is a feasible way from source to sink. In the first step, we just need to find a augmenting path but do not need to concern its capacity. We can use BFS to finish this proccess. Step2: Add the flow Now we have an augmenting path, and then we need to do is subtracting the maximum capacity in the path from each edge's capacity in the path. And here is a point: We also need to add the maximum capacity to all the antiparallel edges' capacity of the path. Why? One edge may be included in different augmenting paths for several times. If the computer choose the edge but it finds out that it put the edge into a wrong augmenting path, choosing the edge's antiparallel edge enables them to regret the choice and recover the original edge. Code #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; class node{//information of the edge public: int to; int c; int nxt; }; class graph{ public: vector&lt;int&gt; head; vector&lt;node&gt; edge; vector&lt;int&gt; pre; vector&lt;int&gt; incf; graph(int a,int s){ head=vector&lt;int&gt;(a+1); pre=vector&lt;int&gt;(a+1); incf=vector&lt;int&gt;(a+1); incf[s]=2147483647; node tmp={0,0,0}; edge.push_back(tmp); edge.push_back(tmp); }; }; void addedge(graph &amp;g,int s,int t,int c){ node tmp={t,c,g.head[s]}; g.edge.push_back(tmp); g.head[s]=g.edge.size()-1; } bool augmenting_path(graph &amp;g,int n,int s,int t){ vector&lt;bool&gt; h=vector&lt;bool&gt;(n+1);//detect the point is visited or not queue&lt;int&gt; q; q.push(s); h[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int y,c,i=g.head[x];i;i=g.edge[i].nxt){ y=g.edge[i].to; c=g.edge[i].c; if(h[y]||!c) continue; g.incf[y]=min(g.incf[x],c); g.pre[y]=i; if(y==t) return 1; h[y]=1; q.push(y); } } return 0; } int increase_flow(graph &amp;g,int s,int t){ int x=t; while(x!=s){ int i=g.pre[x]; g.edge[i].c-=g.incf[t]; g.edge[i^1].c+=g.incf[t]; x=g.edge[i^1].to; } return g.incf[t]; } int main(){ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n;//number of vertexs int m;//number of edges int s;//source vertex int t;//sink vertex cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; graph g(n,s); for(int i=1,a,b,c;i&lt;=m;++i){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; addedge(g,a,b,c); addedge(g,b,a,0); } LL ans=0; while(augmenting_path(g,n,s,t)){ ans+=increase_flow(g,s,t); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } Notice This algorithm is, indeed, a semi-finished product. Thus, it is not very effective. It can be used when the number of vertexs is lower than 10,000. But it provides a principle that used in most other network-flow problems. So totally understanding this algorithm will lay a solid fundation for further study. ","link":"https://dawn-cmd.github.io/fUyI1lct0/"},{"title":"Dijkstra Algorithm","content":"Introduction In this passage, I will explain a algorithm that works on graphs. When we are faced with problems on graphs, we often need to face a very classic problem: Finding a shortest way from A to B. There are two main stream algorithms to solve the problem in the programming competition community.(at least in China) They are Dijskstra and SPFA. However, to SPFA, it is not stable because if the problem-maker draw the graph like a grid, it can reach its most terrible time complexity readily. So the most popular one is Dijsktra. Step1: Core Principle Dijkstra is very easy to understand in the aspect of principle. We use an array dist[i] to represent the shortest way between vertex i and the initial vertex. So the algorithm is that using the dist[i] to update the connected vertexs' information: dist[i.to]&gt;dist[i]+cost[i][i.to]?&quot;update&quot;:&quot;remain&quot;; Step2: Make it Perfect Nevertheless, if we just practice the principle directly, the time complexity is O(n^2)(Here the &quot;O&quot; means theta, I cannot type the symbol easily in my blog) because we repeated N times to find the minimum distance among N distances, which is not acceptable. We can use pile to help us to finish the finding proccess. Because pile can use O(log2N) to find the minimum one among N. The better time complexity is O(nlogn). Step3: Code #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; struct node{ int to; int cost; bool operator &lt;(const node &amp;x)const{ return x.cost&lt;cost; } }; vector&lt;int&gt; dijkstra(int n,int m,int s,vector&lt;vector&lt;node&gt; &gt; &amp;g){ vector&lt;int&gt; dist=vector&lt;int&gt;(n+1); for(int i=1;i&lt;=n;++i){ dist[i]=2147483647; } dist[s]=0;//initialize the distance priority_queue&lt;node&gt; p;//use a priority_queue to decrease the time on finding the minimum number to log2N map&lt;int,int&gt; h; node tmp={s,0}; p.push(tmp); while(!p.empty()){ int x=p.top().to; p.pop(); if(h[x]==1){ continue; }//because each vertex can only be used for one time, this measure can avoid a dead loop h[x]=1; for(int i=0;i&lt;g[x].size();++i){ int y=g[x][i].to; if(dist[y]&gt;dist[x]+g[x][i].cost){ dist[y]=dist[x]+g[x][i].cost; if(!h[y]){ node tmp={y,dist[y]}; p.push(tmp); } } }//follow the principle, use the best data to update } return dist; } int main(){ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n;//total number of vertexs int m;//total number of edges int s;//the initial vertex cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; //input the data vector&lt;vector&lt;node&gt; &gt; g=vector&lt;vector&lt;node&gt; &gt;(n+1);//the graph for(int i=1,x,y,c;i&lt;=m;++i){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;c; node tmp={y,c}; g[x].push_back(tmp); }//store the graph vector&lt;int&gt; dist=dijkstra(n,m,s,g);//calculate the answer for(int i=1;i&lt;=n;++i){ cout&lt;&lt;dist[i]&lt;&lt;' '; }//output the answer cout&lt;&lt;endl; return 0; } Notice This Dijkstra cannot be used on graphs with minus edges. Although this problem can also be solved by using potential function on the algorithm, it will make it more like a maths problem but not information technology problem. So I will not talk too much on it in this blog but I may use another passage to explain the area. ","link":"https://dawn-cmd.github.io/r5xcxY_Zp/"},{"title":"Codeforces Round #663 Div2 retrospect","content":"First, here is my score and rate: A. Suborrays Introduction Here Analysis It's not hard to understand the problem's true meaning: Give a solution that to all subarrays which have length k, there exist at least one number in the subarray no less than k. There is a fixed solution to this problem: 1, 2, 3, ......, n. Code #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; int main(){ int T; cin&gt;&gt;T; while(T--){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i){ cout&lt;&lt;i&lt;&lt;' '; } cout&lt;&lt;endl; } return 0; } B. Fix You Introduction Here Analysis Because all the places can be chosen, the only way and also the best way to solve it is to change all 'D' on the bottom into 'R' and change all 'R' on the right edge into 'D'. Code #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int T; cin&gt;&gt;T; while(T--){ int n; int m; vector&lt;string&gt; g; cin&gt;&gt;n&gt;&gt;m; g=vector&lt;string&gt;(n); for(auto &amp;i:g){ cin&gt;&gt;i; } int ans=0; for(int i=0;i&lt;n;++i){ if(i&lt;n-1){ g[i][m-1]=='R'?++ans:0; } else{ for(auto &amp;j:g[i]){ j=='D'?++ans:0; } } } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } C. Cyclic Permutations Introduction Here Analysis The problem cannot be easily solved straightly. We can find that to any element in this sequence, if it has edge to both left and right, it must be in a circle. It is very easy to verify. So, what we do is to find the number of solution that cannot build a circle and use the number of all solutions n! to minus it. So how we can find the number of solution that cannot build circle? According to the conclusion we get previously, we can put these numbers into a deque by this sequence: n-1, n-2,......, 1, and each number can choose put from the left or from the right. So the answer is n!-2^(n-1). Code #include&lt;bits/stdc++.h&gt; #define LL long long #define MOD 1000000007 using namespace std; long long qpow(long long _b,long long _e){ return _e==0?1:(_e&amp;1?_b:1)*qpow(_b*_b%MOD,_e&gt;&gt;1)%MOD; } int main(){ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); LL n; cin&gt;&gt;n; LL ans=1; for(LL i=2;i&lt;=n;++i){ ans=ans*i%MOD; } cout&lt;&lt;(ans+MOD-qpow(2,n-1))%MOD&lt;&lt;endl; return 0; } ","link":"https://dawn-cmd.github.io/oYNuWB-VD/"},{"title":"Codeforces Round #662 Div2 retrospect","content":"First, here is my score and rate: A. Rainbow Dash, Fluttershy and Chess Coloring Introduction Here Analysis It's very easy, you can find the answer via merely trying 2 to 3 numbers. The answer is n/2+1. That's all. Code #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int T; cin&gt;&gt;T; while(T--){ int n; cin&gt;&gt;n; cout&lt;&lt;n/2+1&lt;&lt;endl; } return 0; } B. Applejack and Storages Introduction Here Analysis First, we can record number of each kind of lumber. Then we can count and update the number of types of lumber which is more than 2, 4, 6 and 8. This whole procedure is O(n). Each time the data is renewed, we can use the record to judge that the requirement in the introduction is accpetable or not. Code #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; map&lt;int,int&gt; h; int cnt2=0; int cnt4=0; int cnt6=0; int cnt8=0; for(int i=1,tmp;i&lt;=n;++i){ cin&gt;&gt;tmp; h[tmp]++; if(h[tmp]==2){ ++cnt2; } if(h[tmp]==4){ ++cnt4; } if(h[tmp]==6){ ++cnt6; } if(h[tmp]==8){ ++cnt8; } } int q; cin&gt;&gt;q; while(q--){ char c; int tmp; cin&gt;&gt;c&gt;&gt;tmp; if(c=='+'){ ++n; ++h[tmp]; if(h[tmp]==2){ ++cnt2; } if(h[tmp]==4){ ++cnt4; } if(h[tmp]==6){ ++cnt6; } if(h[tmp]==8){ ++cnt8; } } else{ --n; --h[tmp]; if(h[tmp]==1){ --cnt2; } if(h[tmp]==3){ --cnt4; } if(h[tmp]==5){ --cnt6; } if(h[tmp]==7){ --cnt8; } } if(n&lt;8){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; continue; } if(cnt8){ cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; continue; } if(cnt6&amp;&amp;cnt2&gt;=2){ cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; continue; } if(cnt4&gt;=2){ cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; continue; } if(cnt4&amp;&amp;cnt2&gt;=3){ cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; continue; } cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; } return 0; } C. Pinkie Pie Eats Patty-cakes Introduction Here Analysis At the first glance, we can judge that the answer of this question is linear. It means that there must exist a value that any value lower than it is acceptable and any value higher than it is not acceptable. So the value is the answer we look for. What's more, the range of answer can up to 2*10^5. Large scale, linear answer, which kind of algorithm or data structure can match these features? Of course, the BINARY SEARCH. It is one of my favourite algorithm and also the first algorithm I learned formally. With a check function, you can locate an answer in logn time complexity. But how to design the check algorithm? We can use the GREEK strategy. At a specific position, choose the legal type of the cake which has the greatest number. In detail, we can use SET to implement it. So, the whole time complexity of the problem is O(nlogn), which is acceptable. Code #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; vector&lt;int&gt; a; int n; bool check(int x){ map&lt;int,int&gt; cnt; for(auto &amp;i:a){ ++cnt[i]; } vector&lt;int&gt; b; set&lt;pair&lt;int,int&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; s; for(int i=1;i&lt;=n;i++){ if(cnt[i]){ s.insert({cnt[i],i}); } } for(int i=0;i&lt;n;++i){ if(i&gt;x&amp;&amp;cnt[b[i-x-1]]){ s.insert({cnt[b[i-x-1]],b[i-x-1]}); } if(s.empty()){ return 0; } b.push_back(s.begin()-&gt;second); s.erase(s.begin()); --cnt[b.back()]; } return 1; } int binary_search(int l,int r){ if(l==r){ return l; } int mid=(l+r)/2+1; if(check(mid)){ return binary_search(mid,r); } else{ return binary_search(l,mid-1); } } int main(){ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int T; cin&gt;&gt;T; while(T--){ cin&gt;&gt;n; a=vector&lt;int&gt;(n); for(auto &amp;i:a){ cin&gt;&gt;i; } cout&lt;&lt;binary_search(0,n)&lt;&lt;endl; } return 0; } ","link":"https://dawn-cmd.github.io/i28zPrNp9/"},{"title":"Codeforces Round #661 Div3 retrospect","content":"First, here is my score and rate: A. Remove Smallest Introduction Here Analysis It's not hard to find that the answer of the question is not related to the order of the array a[]. The critical fact is whether there exist a gap border than 1. To check it, we can sort the array and list it. Due to the sort function, the time complexity of the solution is O(nlogn), which is acceptable. Code #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int T; cin&gt;&gt;T; while(T--){ int n; cin&gt;&gt;n; int a[100]; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;a[i]; } if(n==1){ cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; continue; } sort(a+1,a+1+n); int ans=1; for(int i=1;i&lt;=n-1;++i){ if(a[i+1]-a[i]&gt;1){ ans=0; break; } } if(ans){ cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else{ cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } } return 0; } B. Gifts Fixing Introduction Here Analysis First, we can use c[i] and o[i] to describe the number of candies and oranges in each gift. According to the description, we can only decrease c[i] and o[i]but not increase them. So it is clear that in the end, the number of candies/oranges will be the smallest one in the initial numbers. Let's call them min_c and min_o. As the result, the answer is sum(max(c[i]-min_c,o[i]-min_o))(i&gt;=1&amp;&amp;i&lt;=n) Code #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int T; cin&gt;&gt;T; while(T--){ int n; int c[100]; int o[100]; cin&gt;&gt;n; int minc=1e9+1; int mino=1e9+1; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;c[i]; minc=min(minc,c[i]); } for(int i=1;i&lt;=n;++i){ cin&gt;&gt;o[i]; mino=min(mino,o[i]); } long long ans=0; for(int i=1;i&lt;=n;++i){ ans+=max(c[i]-minc,o[i]-mino); } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } C. Boats Competition Introduction Here Analysis According to the description, it is not hard to find that the maximum of s is 100. So to each data, we try s from 0 to 100, and record the answer. To a specific s, how we can calculate the maximum number of teams? We can use a map to record all the weights, and to each person, we find whether there exist another one to match it. The total time complexity is O(n). Code #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int T; cin&gt;&gt;T; while(T--){ int n; cin&gt;&gt;n; int w[100]; map&lt;int,int&gt; h; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;w[i]; ++h[w[i]]; } if(n==1){ cout&lt;&lt;0&lt;&lt;endl; continue; } if(n==2){ cout&lt;&lt;1&lt;&lt;endl; continue; } int ans=-1; for(int i=1;i&lt;=101;++i){ int cnt=0; map&lt;int,int&gt; p=h; for(int j=1;j&lt;=n;++j){ if(i-w[j]==w[j]&amp;&amp;p[w[j]]&lt;=1){ continue; } if(p[w[j]]==0||p[i-w[j]]==0){ continue; } --p[w[j]]; --p[i-w[j]]; ++cnt; } ans=max(ans,cnt); } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } D. Binary String To Subsequences Introduction Here Analysis In the problem, we do not really cares the body of each subsequence, instead, the end character is the most important to us. When we meet a '0', we need to add it to a '1'-end-subsequence and when we meeet a '1', we need to add it to a '0'-end-subsequence. So we can use two chains to connect the id of '1'-end-subsequences and '0'-end-subquences. The total time complexity of the solution is O(n). Code #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int T; cin&gt;&gt;T; while(T--){ int n; cin&gt;&gt;n; string s; cin&gt;&gt;s; int pre[200010]; int headz=0; int heado=0; int ans=0; int bl[200010]; for(int i=0,len=s.length();i&lt;len;++i){ if(s[i]-'0'==0){ if(heado==0){ ++ans; pre[ans]=headz; headz=ans; bl[i]=ans; } else{ bl[i]=heado; int tmp=pre[heado]; pre[heado]=headz; headz=heado; heado=tmp; } } else{ if(headz==0){ ++ans; pre[ans]=heado; heado=ans; bl[i]=ans; } else{ bl[i]=headz; int tmp=pre[headz]; pre[headz]=heado; heado=headz; headz=tmp; } } } cout&lt;&lt;ans&lt;&lt;endl; for(int i=0;i&lt;n;++i){ cout&lt;&lt;bl[i]&lt;&lt;' '; } cout&lt;&lt;endl; } return 0; } ","link":"https://dawn-cmd.github.io/BKt7ppc1X/"},{"title":"Kick Start 2020 Round D T2 Alien Piano Analysis","content":"Official Link Here Problem An alien has just landed on Earth, and really likes our music. Lucky for us. The alien would like to bring home its favorite human songs, but it only has a very strange instrument to do it with: a piano with just 4 keys of different pitches. The alien converts a song by writing it down as a series of keys on the alien piano. Obviously, this piano will not be able to convert our songs completely, as our songs tend to have many more than 4 pitches. The alien will settle for converting our songs with the following rules instead: The first note in our song can be converted to any key on the alien piano. For every note after, if its pitch is higher than the previous note, it should be converted into a higher-pitched key than the previous note's conversion; if lower, it should be converted into a lower-pitched key than the previous note's conversion; if exactly identical, it should be converted into the same key as the previous note's conversion. Note: two notes with the same pitch do not need to be converted into the same key if they are not adjacent. What the alien wants to know is: how often will it have to break its rules when converting a particular song? To elaborate, let us describe one of our songs as having K notes. The first note we describe as &quot;note 1&quot;, the second note &quot;note 2&quot;, and the last note &quot;note K.&quot; So note 2 comes immediately after note 1. Now if note 2 is lower than note 1 in our version of the song, yet converted to an equally-pitched or lower-pitched key (relative to note 2's conversion) in the alien's version of the song, then we consider that a single rule break. For each test case, return the minimum amount of times the alien must necessarily break one of its rules in converting that song. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case consists of two lines. The first line consists of a single integer, K. The second line consists of K space-separated integers, A1, A2 ... AK, where Ai refers to the pitch of the i-th note for this test case. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum number of times that particular test case will require the alien to break its own rules during the conversion process. Limits Memory limit: 1GB. 1 ≤ T ≤ 100. 1 ≤ Ai ≤ 106. Test set 1 Time limit: 20 seconds. 1 ≤ K ≤ 10. Test set 2 Time limit: 40 seconds. 1 ≤ K ≤ 104. Analysis O(4^K) Solution: We can generate all possible conversions and choose the one with the smallest number of violations. To a fixed K, there exist 4^K solutions, so the time complexity is O(4^K). O(K) Solution1: When I was finishing this problem, I first came up with DP--Dynamic programming. We can consider dp[i][j] as the smallest number of violation when you choose conversion j at the position of i. So dp[i][j] equals to min(dp[i-1][k]+(violate the rule?1:0)). Because we just need one layer of loop, so the time complexity is O(K). O(K) Solution2: We can interpret the problem through this way: record the number of ascending or descending substrings which is longer than 4. We just need to make sure each element is ergodic. Code of O(K) Solution 1: #include&lt;bits/stdc++.h&gt; using namespace std; int n; int a[10010]; int dp[10010][6]; void initialization(){ memset(a,0,sizeof a); memset(dp,0,sizeof dp); return; } int main(){ int T; cin&gt;&gt;T; for(int cas=1;cas&lt;=T;++cas){ initialization(); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;a[i]; if(i!=1&amp;&amp;a[i]==a[i-1]){ --i; --n; } } for(int i=1;i&lt;=4;++i){ dp[1][i]=0; } for(int i=2;i&lt;=n;++i){ for(int j=1;j&lt;=4;++j){ dp[i][j]=2147483647; if(a[i]&gt;a[i-1]){ for(int k=1;k&lt;=4;++k){ if(k&lt;j){ dp[i][j]=min(dp[i][j],dp[i-1][k]); } else{ dp[i][j]=min(dp[i][j],dp[i-1][k]+1); } } } else{ for(int k=1;k&lt;=4;++k){ if(k&gt;j){ dp[i][j]=min(dp[i][j],dp[i-1][k]); } else{ dp[i][j]=min(dp[i][j],dp[i-1][k]+1); } } } } } int ans=2147483647; for(int i=1;i&lt;=4;++i){ ans=min(ans,dp[n][i]); } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } Code of O(K) Solution 2: #include&lt;bits/stdc++.h&gt; using namespace std; int n; int main(){ int T; cin&gt;&gt;T; for(int cas=1;cas&lt;=T;++cas){ cin&gt;&gt;n; int now; int pre; int ans=0; int upcnt=0; int downcnt=0; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;now; if(i==1||now==pre){ pre=now; continue; } if(now&gt;pre){ upcnt++; downcnt=0; } else{ upcnt=0; downcnt++; } if(upcnt&gt;3||downcnt&gt;3){ ++ans; upcnt=0; downcnt=0; } pre=now; } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } ","link":"https://dawn-cmd.github.io/cJ22lJu5P/"},{"title":"Kick Start 2020 Round D T1 Record Breaker Analysis","content":"Official Link Here Problem Isyana is given the number of visitors at her local theme park on N consecutive days. The number of visitors on the i-th day is Vi. A day is record breaking if it satisfies both of the following conditions: The number of visitors on the day is strictly larger than the number of visitors on each of the previous days. Either it is the last day, or the number of visitors on the day is strictly larger than the number of visitors on the following day. Note that the very first day could be a record breaking day! Please help Isyana find out the number of record breaking days. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. The second line contains N integers. The i-th integer is Vi. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the number of record breaking days. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 ≤ T ≤ 100. 0 ≤ Vi ≤ 2 × 105. Test set 1 1 ≤ N ≤ 1000. Test set 2 1 ≤ N ≤ 2 × 105 for at most 10 test cases. For the remaining cases, 1 ≤ N ≤ 1000. Sample Input 4 8 1 2 0 7 2 0 2 0 6 4 8 15 16 23 42 9 3 1 4 1 5 9 2 6 5 6 9 9 9 9 9 9 Output Case #1: 2 Case #2: 1 Case #3: 3 Case #4: 0 Explanation In Sample Case #1, the bold and underlined numbers in the following represent the record breaking days: 1 2 0 7 2 0 2 0. In Sample Case #2, only the last day is a record breaking day. In Sample Case #3, the first, the third, and the sixth days are record breaking days. In Sample Case #4, there is no record breaking day. Analysis O(n^2) Solution: To every V[i], we can check all the previous numbers to verify whether it breaks the record or not. So it is an O(n^2) Solution, it is enough to pass the time set one. O(n) Solution: We can list all v[i] and use a varition RECORD to record the existed record(???). When a v[i] break the record, it satisfy the first requirement, thus, we just need to check whether it satisfies the second requirement or not. The total time complexity of the solution is O(n), it is enough to pass the time set two. Code of the best solution #include&lt;bits/stdc++.h&gt; using namespace std; int n; int v[200010]; int main(){ int T; cin&gt;&gt;T; for(int cas=1;cas&lt;=T;++cas){ cin&gt;&gt;n; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;v[i]; } int maxn=-1; int ans=0; for(int i=1;i&lt;=n;++i){ if(v[i]&gt;maxn){ if(i==n||v[i]&gt;v[i+1]){ ++ans; } maxn=v[i]; } } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } ","link":"https://dawn-cmd.github.io/76NaE9Spv/"},{"title":"Kick Start 2020 Round C T3 Perfect Subarray Analysis","content":"Problem Cristobal has an array of N (possibly negative) integers. The i-th integer in his array is Ai. A contiguous non-empty subarray of Cristobal's array is perfect if its total sum is a perfect square. A perfect square is a number that is the product of a non-negative integer with itself. For example, the first five perfect squares are 0, 1, 4, 9 and 16. How many subarrays are perfect? Two subarrays are different if they start or end at different indices in the array, even if the subarrays contain the same values in the same order. Input The first line of the input gives the number of test cases, T. T test cases follow. The first line of each test case contains the integer N. The second line contains N integers describing Cristobal's array. The i-th integer is Ai. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the number of perfect subarrays. Limits Memory limit: 1GB. 1 ≤ T ≤ 100. -100 ≤ Ai ≤ 100, for all i. Test set 1 Time limit: 20 seconds. 1 ≤ N ≤ 1000. Test set 2 Time limit: 30 seconds. For up to 5 cases, 1 ≤ N ≤ 105. For the remaining cases, 1 ≤ N ≤ 1000. Sample Input 3 3 2 2 6 5 30 30 9 1 30 4 4 0 0 16 Output Case #1: 1 Case #2: 3 Case #3: 9 Explanation In sample case #1, there is one perfect subarray: [2 2] whose sum is 22. In sample case #2, there are three perfect subarrays: [9], whose total sum is 32. [1], whose total sum is 12. [30 30 9 1 30], whose total sum is 102. In sample case #3, there are nine perfect subarrays: [4], whose total sum is 22. [4 0], whose total sum is 22. [4 0 0], whose total sum is 22. [0], whose total sum is 02. [0 0], whose total sum is 02. [0 0 16], whose total sum is 42. [0], whose total sum is 02. [0 16], whose total sum is 42. [16], whose total sum is 42. Note We do not recommend using interpreted/slower languages for the test set 2 of this problem. Anaylsis O(n^2) Solution: Easily, we only need to check every subarray in it. In an n-length array, there exist n*(n+1)/2 subarrays. So the time complexity of this algorithm is O(n^2). O(nsqrt(1e7) to nlogn*sqrt(1e7)) Solution: First, we use sum[] to record the prefix sum of a[]. So the problem becomes: how many sum[i]-sum[j-1]=x^2(i&gt;=j &amp;&amp; x is an integer). This formula equals to sum[j-1]=sum[i]-x^2. So, all we need to do is to enumerate all possible x and check how many j meet the requirement. To implement it, we can use a hash table to record the number of exist sum[j], which has a O(1) time complexity. This algorithm's time complexity can be accepted narrowly. Code of the best Solution #include&lt;bits/stdc++.h&gt; #define BASE 15000000 #define LL long long using namespace std; int n; int a[100010]; LL h[70000010]; int main(){ int T; cin&gt;&gt;T; for(int cas=1;cas&lt;=T;++cas){ memset(h,0,sizeof h); LL ans=0; cin&gt;&gt;n; h[BASE]=1; a[0]=BASE; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;a[i]; a[i]+=a[i-1]; } int minn=BASE; for(int i=1;i&lt;=n;++i){ for(int j=0;j*j&lt;=10000000;++j){ if(a[i]-j*j&lt;minn){ break; } ans+=h[a[i]-j*j]; } minn=min(a[i],minn); h[a[i]]++; } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } P.S. If you use C++ to solve this problem, do not use map, which will add a logn to your time complexity. You should use long long to save the answer. Do not use Python. ","link":"https://dawn-cmd.github.io/r6whUkCyg/"},{"title":"Topological Sort","content":"Introduction Many times, the sort of our works are fixed in some degrees: you may be able to change the order of washing your face and brushing your teeth, but you cannot change the order of getting out and dressing up. Yes, many things have a comparative order, which means that they are neither totally fixed nor sheer random. So it is very difficult to determine the sort by normal ways, as a result, here comes the Topological Sort. Defination Topological Sort is linear sort of a Directed Acyclic Graph(DAG). The DAG is often used to represent a complicated dependancy relationship. Implementation We can use either DFS or BFS to solve it. But the core mechanisms of these two algorithms are same -- find the 0-in-degree vertaxs, add them to the answer, eliminate all the edges from it, and then repeats it until there is no 0-in-degree vertaxs. DFS code: #include&lt;bits/stdc++.h&gt; using namespace std; int n; int m; vector&lt;int&gt; mp[200]; int incnt[200]; vector&lt;int&gt; ans; void Topo(int now){ ans.push_back(now); for(int i=0;i&lt;mp[now].size();++i){ int y=mp[now][i]; --incnt[y]; if(incnt[y]==0){ Topo(y); } } return; } int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;++i){ int x; int y; cin&gt;&gt;x&gt;&gt;y; mp[x].push_back(y); incnt[y]++; } for(int i=1;i&lt;=n;++i){ mp[0].push_back(i); incnt[i]++; } Topo(0); for(int i=1;i&lt;ans.size();++i){ cout&lt;&lt;ans[i]&lt;&lt;' '; } cout&lt;&lt;endl; return 0; } BFS code: #include&lt;bits/stdc++.h&gt; using namespace std; int n; int m; vector&lt;int&gt; mp[200]; vector&lt;int&gt; ans; int incnt[200]; void Topo(){ queue&lt;int&gt; q; q.push(0); while(!q.empty()){ int x=q.front(); ans.push_back(x); q.pop(); int y; for(int i=0;i&lt;mp[x].size();++i){ y=mp[x][i]; incnt[y]--; if(incnt[y]==0){ q.push(y); } } } return; } int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;++i){ int x; int y; cin&gt;&gt;x&gt;&gt;y; mp[x].push_back(y); incnt[y]++; } for(int i=1;i&lt;=n;++i){ mp[0].push_back(i); incnt[i]++; } Topo(); for(int i=1;i&lt;ans.size();++i){ cout&lt;&lt;ans[i]&lt;&lt;' '; } cout&lt;&lt;endl; return 0; } In the end Topological sort is one of the basic graph algorithms. I will appreciate you if you think this blog is beneficial. Moreover, this problem can serve as a good case in point. ","link":"https://dawn-cmd.github.io/o_E2mKnup/"},{"title":"Kick Start 2020 Round C T1 Countdown Analysis","content":"Official link Here Problem Avery has an array of N positive integers. The i-th integer of the array is Ai. A contiguous subarray is an m-countdown if it is of length m and contains the integers m, m-1, m-2, ..., 2, 1 in that order. For example, [3, 2, 1] is a 3-countdown. Can you help Avery count the number of K-countdowns in her array? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integers N and K. The second line contains N integers. The i-th integer is Ai. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the number of K-countdowns in her array. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 ≤ T ≤ 100. 2 ≤ K ≤ N. 1 ≤ Ai ≤ 2 × 10^5, for all i. Test set 1 2 ≤ N ≤ 1000. Test set 2 2 ≤ N ≤ 2 × 10^5 for at most 10 test cases. For the remaining cases, 2 ≤ N ≤ 1000. Analysis O(nk) solution:for each A[i to i+k], we can check it whether meets the requirement in the problem or not. O(n) solution: We can set a variation &quot;head&quot;. At first, head equals to k. If A[i] equals to head, head minus one, otherwise reset head. When head equals to 0, we find a countdown, and then we need to add it to the answer and reset head. Code of the best solution #include&lt;bits/stdc++.h&gt; using namespace std; int n; int k; int main(){ int T; cin&gt;&gt;T; for(int P=1;P&lt;=T;++P){ cin&gt;&gt;n&gt;&gt;k; int head=k; int ans=0; for(int i=1;i&lt;=n;++i){ int now; cin&gt;&gt;now; if(now==head){ --head; } else{ head=now==k?k-1:k; } if(head==0){ ++ans; head=k; } } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;P&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } P.S. When you reset head, checking adjacent number is necessary.&gt;line 19 ","link":"https://dawn-cmd.github.io/kick-start-2020-round-c-t1-countdown-analysis/"},{"title":"Kick Start 2020 Round C T2 Stable_Wall Analysis","content":" Before the passage I think the data of this problem should be strengthened. Because of the weak data, many people can solve the problem via a very stupid way(me). the details will be furnished in the following passage. However, the ratio of people who passed the problem is lower than the one in other contemporary rounds, it is unbelievable. Official link Here Problem Apollo is playing a game involving polyominos. A polyomino is a shape made by joining together one or more squares edge to edge to form a single connected shape. The game involves combining N polyominos into a single rectangular shape without any holes. Each polyomino is labeled with a unique character from A to Z. Apollo has finished the game and created a rectangular wall containing R rows and C columns. He took a picture and sent it to his friend Selene. Selene likes pictures of walls, but she likes them even more if they are stable walls. A wall is stable if it can be created by adding polyominos one at a time to the wall so that each polyomino is always supported. A polyomino is supported if each of its squares is either on the ground, or has another square below it. Apollo would like to check if his wall is stable and if it is, prove that fact to Selene by telling her the order in which he added the polyominos. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers R and C. Then, R lines follow, describing the wall from top to bottom. Each line contains a string of C uppercase characters from A to Z, describing that row of the wall. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is a string of N uppercase characters, describing the order in which he built them. If there is more than one such order, output any of them. If the wall is not stable, output -1 instead. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 ≤ T ≤ 100. 1 ≤ R ≤ 30. 1 ≤ C ≤ 30. No two polyominos will be labeled with the same letter. The input is guaranteed to be valid according to the rules described in the statement. Test set 1 1 ≤ N ≤ 5. Test set 2 1 ≤ N ≤ 26. Sample Input 4 4 6 ZOAAMM ZOAOMM ZOOOOM ZZZZOM 4 4 XXOO XFFO XFXO XXXO 5 3 XXX XPX XXX XJX XXX 3 10 AAABBCCDDE AABBCCDDEE AABBCCDDEE Output Case #1: ZOAM Case #2: -1 Case #3: -1 Case #4: EDCBA Explainatoin In sample case #1, note that ZOMA is another possible answer. In sample case #2 and sample case #3, the wall is not stable, so the answer is -1. In sample case #4, the only possible answer is EDCBA. Analysis O(n!) solution:We can list all the possible order that the polyominos being set in and then check them one by one. O(n to n!) solution:this is the stupid wayWhen I was solving the problem, I used DFS technique(Deep-First-Search) to address it. Specifically, I imitated the process of setting polyomino: I determined which polyomino I should put one by one, when there exist problems, we back to the previous step and try another way. Because N is specially small, this solution can be accepted narrowly. O(R * C) solution:So this is the best solution. Literally, when a polyomino is totally or partly above another polyomino, the upper one should be set after the lower one restrictly. When it happpens, we can consider these two polyominos as two vertexs, and build an edge directed from the lower one to the upper one. We proceed all the polyominos by this way, in the end, we can get a graph. All we need to do is to find a topological sort of the graph. About topological sort, if you do not know it very well, this passage may help you. Code of my solution #include&lt;bits/stdc++.h&gt; using namespace std; int T; int r; int c; string ans; string mp[31]; string lit; map&lt;char,int&gt; h; bool check(){ for(int i=1;i&lt;r;++i){ for(int j=0;j&lt;c;++j){ if(h[mp[i][j]]==0&amp;&amp;h[mp[i-1][j]]==1){ return 0; } } } return 1; } void dfs(string now){ if(now.length()==lit.length()){ ans=now; return; } if(ans!=&quot;-1&quot;){ return; } for(int i=0;i&lt;lit.length();++i){ if(h[lit[i]]==1){ continue; } h[lit[i]]=1; if(check()){ dfs(now+lit[i]); } h[lit[i]]=0; } } int main(){ cin&gt;&gt;T; for(int P=1;P&lt;=T;++P){ cin&gt;&gt;r&gt;&gt;c; lit=&quot;&quot;; h.erase(h.begin(),h.end()); for(int i=0;i&lt;r;++i){ cin&gt;&gt;mp[i]; for(int j=0;j&lt;c;++j){ if(h[mp[i][j]]==0){ h[mp[i][j]]=1; lit+=mp[i][j]; } } } h.erase(h.begin(),h.end()); ans=&quot;-1&quot;; dfs(&quot;&quot;); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;P&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } return 0; } Code of the best solution #include&lt;bits/stdc++.h&gt; using namespace std; int r; int c; string mp[1000]; vector&lt;int&gt; graph[1000]; int incnt[1000]; int n; string ans; map&lt;char,int&gt; h; void topo(){ queue&lt;int&gt; q; for(int i=1;i&lt;=30;++i){ if(incnt[i]==0&amp;&amp;h[(char)(i+'A'-1)]){ q.push(i); } } while(!q.empty()){ int x=q.front(); ans+=(char)(x+'A'-1); q.pop(); for(int i=0;i&lt;graph[x].size();++i){ int y=graph[x][i]; incnt[y]--; if(incnt[y]==0){ q.push(y); } } } return; } int main(){ int T; cin&gt;&gt;T; for(int P=1;P&lt;=T;++P){ cin&gt;&gt;r&gt;&gt;c; n=0; h.erase(h.begin(),h.end()); for(int i=0;i&lt;r;++i){ cin&gt;&gt;mp[i]; for(int j=0;j&lt;c;++j){ if(h[mp[i][j]]==0){ h[mp[i][j]]=1; ++n; } } } memset(incnt,0,sizeof incnt); map&lt;pair&lt;int,int&gt;,int&gt; he; for(int i=1;i&lt;=30;++i){ graph[i].clear(); } for(int i=1;i&lt;r;++i){ for(int j=0;j&lt;c;++j){ if(mp[i][j]!=mp[i-1][j]){ int x=mp[i][j]-'A'+1; int y=mp[i-1][j]-'A'+1; if(he[make_pair(x,y)]==0){ graph[x].push_back(y); he[make_pair(x,y)]=1; ++incnt[y]; } } } } ans=&quot;&quot;; topo(); if(ans.length()&lt;n){ cout&lt;&lt;&quot;Case #&quot;&lt;&lt;P&lt;&lt;&quot;: &quot;&lt;&lt;&quot;-1&quot;&lt;&lt;endl; } else{ cout&lt;&lt;&quot;Case #&quot;&lt;&lt;P&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; } } return 0; } ","link":"https://dawn-cmd.github.io/kick-start-2020-round-c-t2-stable_wall-analysis/"}]}