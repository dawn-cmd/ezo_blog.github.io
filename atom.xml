<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dawn-cmd.github.io</id>
    <title>Blog</title>
    <updated>2021-04-11T14:09:06.223Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dawn-cmd.github.io"/>
    <link rel="self" href="https://dawn-cmd.github.io/atom.xml"/>
    <subtitle>People who know nothing repeat it.
</subtitle>
    <logo>https://dawn-cmd.github.io/images/avatar.png</logo>
    <icon>https://dawn-cmd.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Blog</rights>
    <entry>
        <title type="html"><![CDATA[Introduction of Dynamic Programming]]></title>
        <id>https://dawn-cmd.github.io/post/introduction-of-dynamic-programming/</id>
        <link href="https://dawn-cmd.github.io/post/introduction-of-dynamic-programming/">
        </link>
        <updated>2021-04-10T01:05:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="about-this-article">About this article</h2>
<p>This time let's talk about a critical part of algorithm: Dynamic Programming(DP). Actually, I wanted to write about it for a long time. However, its complexity makes me cannot start writing until now. Cause instead of a specific method, DP is more like a system of methods, or a special angle to see the problems. This time we will introduce DP in general and unfold each specific point in the future.</p>
<h2 id="basic-introduction">Basic introduction</h2>
<p>We often see problems that seems periodic or consisted of several similar sub-problems are hard to solve directly, like the famous Fibonacci Sequence. Although we all know that the sequence has a direct function, most people are more familiar with this: f(n) = f(n - 1) + f(n - 2), which is more clear and practicable. This is a typical example of DP, which has direct <code>&quot;optimal substructures&quot;</code> and <code>&quot;recursive sub-problems&quot;</code>. &quot;Optimal substructure&quot; means the optimal solution of this problem can totally inferred from its subproblems optimal solutions. &quot;Recursive subproblems&quot; means the problem itself is similar to its subproblems in general.</p>
<h2 id="common-structure">Common structure</h2>
<p>Before we actually practice it in problems, we need to understand the common steps to make sure we have a clear direction.</p>
<p>All DP solutions are consisted of three parts: <code>Level</code>, <code>State</code>, and <code>State Transformation Functions</code>:</p>
<ul>
<li>
<p>Level: The basic unit we want to divide the problem into. In Fibonacci Sequence problem, each position in the sequence is the level we define. Interestingly, many problems have several different DP solution depended on the choice of level, and the time compexity and difficulty of practicing will change as well.</p>
</li>
<li>
<p>State: Specific data the level has. In equations, we often use varibles like i, j, and k to represent state. Yet in some special situations, the state will give a answer that does not follow the other's rule, for example, the border limitation.</p>
</li>
<li>
<p>State Transformation Function: The core function of a DP solution. It directly represents how optimal solution of the problem can be inferred from the optimal solutions of its subproblems.</p>
</li>
</ul>
<h2 id="example-fibonacci-sequence">Example: Fibonacci Sequence</h2>
<p>In this example, I will show two basic methods of actualizing DP.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int dp(int k) {
    if(k == 0) return 0;
    if(k == 1) return 1;
    return dp(k - 1) + dp(k - 2);
} 
int main() {
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; dp(n) &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>The first way, just showed above, is using a function to imitate the process. However, obviously it is an ineffective way because there exist too many repeated steps. Of course there are ways to solve it, but let's see the next method first.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() {
    int n;
    cin &gt;&gt; n;
    vector&lt;long long&gt; dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for(int i = 2; i &lt;= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    cout &lt;&lt; dp[n] &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>The next way is using a array to imitate the solution. It seems faster than the previous method. But it has a fatal shortcoming: you must make sure that the state will increase or decrease in a fixed direction. Otherwise you cannot use this method.</p>
<h2 id="the-end">The end</h2>
<p>So this is the end of the introduction. Of course, it is just a beginning of this series. DP is an interesting subject to study. It can also be used in mathmatics, biology, economic and so on.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Manacher]]></title>
        <id>https://dawn-cmd.github.io/post/ntYB0fMZm/</id>
        <link href="https://dawn-cmd.github.io/post/ntYB0fMZm/">
        </link>
        <updated>2021-02-17T02:31:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>Manacher algorithm can be used in most palindrome string problems. It provides a solution with O(n) time complexity.</p>
<h2 id="sample-problem">Sample problem</h2>
<p><a href="https://www.luogu.com.cn/problem/P3805">LuoguP3805</a><br>
Give you a string S. Calculate the length of the longest palindrome substring in it.<br>
1 &lt; length &lt; 1.1e7</p>
<h2 id="solution-1">Solution 1:</h2>
<p>Try every subtring and scan all of them to update the answer. Because we enumerate the left bound and right bound and check each character in the substring. Its time complexity is O(n^3). Actually, it is far from optimal condition.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
bool check(int st, int ed, string s) {
    while (st &lt;= ed) {
        if (s[st] != s[ed]) return 0;
        st++, ed--;
    }
    return 1;
}
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    string s;
    cin &gt;&gt; s;
    int ans = -1;
    for (int i = 0, l = s.size(); i &lt; l; ++i) {
        for (int j = i; j &lt; l; ++j) {
            if (check(i, j, s)) ans = max(ans, j - i + 1);
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dawn-cmd.github.io/post-images/1613568323104.png" alt="" loading="lazy"></figure>
<h2 id="solution-2">Solution 2:</h2>
<p>Let's try to improve it. After observation, we find that we can enumerate the mid point of the palindrome string. Then expand until it touch its bound. The time complexity will become O(n^2), much faster. However, sometimes the mid point is between two characters. If we deal with the strings with odd number of characters and even number of characters separately, the code will become tedious. Using &quot;temp character&quot; can solve it elegantly. We can fill '#' (or some other characters that does not exist in the string) in the position between characters to simplify the code.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
string change (string s) {
    string ans = &quot;+#&quot;;
    for (auto &amp;i: s) {
        ans += i;
        ans += '#';
    }
    ans += &quot;-&quot;;
    return ans;
}
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    string s;
    cin &gt;&gt; s;
    s = change(s);
    int ans = -1;
    for (int i = 1, len = s.size() - 1; i &lt; len; ++i) {
        int tmp = 0;
        while (s[i + tmp + 1] == s[i - tmp - 1]) ++tmp;
        ans = max(ans, tmp);
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://dawn-cmd.github.io/post-images/1613614637904.png" alt="" loading="lazy"></figure>
<p>As we see, it really made some progress. But still cannot satisfy the need.</p>
<h2 id="solution-3">Solution 3</h2>
<p>Here comes our leading role, the manacher algorithm. In fact, its core idea is quite easy to understand:<br>
<img src="https://dawn-cmd.github.io/post-images/1613615453237.png" alt="" loading="lazy"><br>
When you find a palindrome string in the half of another palindrome, it is obvious that there exist a totally same palindrome at the symmetry position. When we meet this situation, we can give the length of the palindrome in O(1).</p>
<p>So we can maximize this idea. We choose the largest palindrome string that reach the most far position as the base palindrome and record its mid point and right bound (because we just need these, we call them max_right and max_mid in the following passage). When the mid point i's id is small than max_right, we can immediately know its radius is at least radius[mid * 2 - i].</p>
<p>But here is a point, why we use &quot;at least&quot; but not &quot;exactly is&quot;? Sometimes i + radius[i] may touch max_right and the excceeding part will not follow the role, so we need update. Moreover, when this happen, we need to update max_right and max_mid as well.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
string change (string base) {
    string ans = &quot;+#&quot;;
    for (auto &amp;i: base) {
        ans += i;
        ans += '#';
    }
    ans += &quot;-&quot;;
    // The string will be in the form like &quot;+#a#b#c#-&quot;. Adding '#' between characters
    // can help us standardize strings with odd length and even length. The '+' and '-'
    // are marks of ending that can help us end loops easily. I will explain it in detail later.
    return ans;
}
void manacher (string &amp;s, vector &lt;int&gt; &amp;p) {
    int max_right = 0;  // the right bound we have calculated
    int max_mid = 0;  // the mid point of the largest palindrome string that contains max_right
    for (int i = 1, l = s.size(); i &lt; l; ++i) {
        p[i] = i &lt;= max_right  // if i is still in range
               ? min(max_right - i, p[(max_mid &lt;&lt; 1) - i])  // we can use its bro's data directly
               : 0;  // otherwise, we can just calculate it from beginning
        while (s[i + p[i] + 1] == s[i - p[i] - 1]) ++p[i];  // expand the length, the loop will end automacally.
        if (max_right &lt; i + p[i]) max_right = i + p[i], max_mid = i;  // update max_right and max_mid
    }
    return;
}
int main () {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    string s;
    cin &gt;&gt; s;
    s = change(s);  // pretreatment
    vector &lt;int&gt; p (s.size());  // p[i] means the radius of the palindrome string with a mid point at i (exclude i itself).
    manacher(s, p);
    int ans = -1;
    for(int i = 0, l = p.size(); i &lt; l; ++i) {
        ans = max(ans, p[i]);  
        // Cause we have pretreated s, its length is 2 times larger than before.
        // So, p[i] itself represents the actually length of its palindrome string.
        // But not the radius.
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://dawn-cmd.github.io/post-images/1613638344217.png" alt="" loading="lazy"></figure>
<h2 id="about-time-complexity">About time complexity</h2>
<p>This algorithm is O(n): when i cannot update max_right, we can get the answer in O(1); when i can update max_right, we need O(n) to update it.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Circle-Based Tree]]></title>
        <id>https://dawn-cmd.github.io/post/5vxYJM5Nd/</id>
        <link href="https://dawn-cmd.github.io/post/5vxYJM5Nd/">
        </link>
        <updated>2021-01-31T02:58:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="basic-definition-two-main-principle">Basic Definition &amp; Two Main Principle</h2>
<p>Just like zero point is not a point, circle-based tree is not a tree as well.<br>
Circle-based Tree, a graph with n vertexs and n edges, has one or more circles in it.</p>
<figure data-type="image" tabindex="1"><img src="https://dawn-cmd.github.io/post-images/1612143955427.png" alt="" loading="lazy"></figure>
<p>The graph has only one circle when the whole graph is connected. In other cases, it will form a &quot;Circle-Based Forest&quot;.</p>
<figure data-type="image" tabindex="2"><img src="https://dawn-cmd.github.io/post-images/1612143997831.png" alt="" loading="lazy"></figure>
<p>When we deal with problems relate to it, we can follow two main idea:</p>
<ul>
<li>Refine the circle from graph, then the graph will be like that some child - trees hang on the circle. Process the data on child-trees and return data to vertexs on circle. Finally, solve the circle problem.</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://dawn-cmd.github.io/post-images/1612144344053.png" alt="" loading="lazy"></figure>
<ul>
<li>Choosing to overlook an edge is also a direction. If we ignore an edge in the graph, it will become a simple tree.</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://dawn-cmd.github.io/post-images/1612146199022.png" alt="" loading="lazy"></figure>
<h2 id="practise">Practise</h2>
<h3 id="cf711d">CF711D</h3>
<ul>
<li>
<p>Describe:<br>
Give you a graph with n edges without directions and n vertexs. You can define every edge's direction. Calculate there are how many solutions that can let the graph have no circle.</p>
</li>
<li>
<p>Solution:<br>
First, as all we known, there existed 2^n solutions. Then we need to minus the solution that has circles from it. This is a graph with n edges and n vertexs. Actually, it is a circle-based tree. The edges in the circle must point in the same way. Otherwise, it is not a circle.</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://dawn-cmd.github.io/post-images/1612358736984.png" alt="" loading="lazy"></figure>
<p>Other edges' direction are indifferent. Cause it will neither break existed circles, nor add new circles.</p>
<p>Obviously, the illegal number of illegal solutions is 2^(n - len) * 2, len is the length of the circle. Hence, there are (2 ^ len - 2) * 2 ^ (n - len) legal solutions. And we successfully beat the problem ......</p>
<p>Not yet.</p>
<p>The problem didn't mention that the graph is connected. So there may not be only one circle. To each isolated graph, we need to add them all.</p>
<ul>
<li>Code:</li>
</ul>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define MOD ((int)1e9 + 7)
using namespace std;
vector &lt;int&gt; graph[(int)2e5 + 1];
int vis[(int)2e5 + 1];
int dfs(int now, int fa, int depth, int &amp;cnt) {
    if (vis[now] &amp;&amp; vis[fa] == 1) {
        vis[now] += 1;
        return -depth;   
    }
    if (vis[now] &amp;&amp; vis[fa] == 2) {
        return 0;
    }
    if (vis[now] == 2) {
        return 0;
    }
    vis[now] += 1;
    cnt += 1;
    if (graph[now].size() == 1) {
       return 1;
    }
    int ans = 1;
    for (int i = 0, l = graph[now].size(); i &lt; l; ++i) {
         int t = graph[now][i];
         if (t == fa) continue;
         ans += dfs(t, now, depth + 1, cnt);
    }
    return ans;
}
ll qpow(ll x, ll b) {
    if (b == 0) return 1;
    if (b &amp; 1) return x * qpow(x * x % MOD, b &gt;&gt; 1) % MOD;
    else return qpow(x * x % MOD, b &gt;&gt; 1);
}
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i) {
        int tmp;
        cin &gt;&gt; tmp;
        graph[tmp].push_back(i);
        graph[i].push_back(tmp);
    }
    memset(vis, 0, sizeof vis);
    ll ans = 0;
    for (int i = 1; i &lt;= n; ++i) {
        if (vis[i]) {
            continue;
        }
        int cnt = 0;
        int s = dfs(i, -1, 0, cnt);
        ans = (ans + (qpow(2, cnt) - qpow(2, s) * 2 % MOD + MOD) % MOD) % MOD;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deep Analysis: Fancy Sequence]]></title>
        <id>https://dawn-cmd.github.io/post/FYQ2RAKvZ/</id>
        <link href="https://dawn-cmd.github.io/post/FYQ2RAKvZ/">
        </link>
        <updated>2020-12-22T12:46:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="problem-description">Problem Description</h2>
<p>Write an API that generates fancy sequences using the append, addAll, and multAll operations.<br>
Implement the Fancy class:</p>
<ul>
<li>Fancy() Initializes the object with an empty sequence.</li>
<li>void append(val) Appends an integer val to the end of the sequence.</li>
<li>void addAll(inc) Increments all existing values in the sequence by an integer inc.</li>
<li>void multAll(m) Multiplies all existing values in the sequence by an integer m.</li>
<li>int getIndex(idx) Gets the current value at index idx (0-indexed) of the sequence modulo 109 + 7. If the index is greater or equal than the length of the sequence, return -1.</li>
</ul>
<h2 id="constrains">Constrains</h2>
<p>1 &lt;= val, inc, m &lt;= 100<br>
0 &lt;= idx &lt;= 10^5<br>
At most 10^5 calls total will be made to append, addAll, multAll, and getIndex.</p>
<h2 id="solution-1-binary-indexed-tree">Solution 1: Binary Indexed Tree:</h2>
<p>This time, I will not list the violent solution because it is too apperant.  First, we can find that all the operations are add and multiply. This two modifications can add up under a mod. So this problem can be understanded in this way: each add and multiply demand can be seem as a node on a list and each node just affect the numbers before it. So when numbers come in, it will not be affected by previous buffs. When you try to get a specific number in the list, you just add all the previous buffs onto the number.</p>
<p>Obviously, prefix sum can satisfied our needs. So what's the most direct and simple data structure that can achieve prefix sum? Binary Indexed Tree. Because I have already write an article to talk about the realization of Binary Indexed Tree, I will just choose some key points to mention here. The problem is, how to &quot;add&quot; buffs. Can we just add them up simply? Of course not. Let's assume f(x) = ax + b, g(x) = cx + d, and the f + g is a*cx + b * c + d. Although the two functions cannot be reversed, it will not affect the final answer.</p>
<pre><code class="language-python">class Fancy:

    mod = 10 ** 9 + 7

    class expression:  # f(x) = a * x + b
        mod = 10 ** 9 + 7
        def __init__(self, x = 1, y = 0):
            self.a, self.b = x, y
        def __add__(self, other):
            self.a = self.a * other.a % self.mod
            self.b = (self.b * other.a + other.b) % self.mod
            return self

    lowbit = lambda self, x: x &amp; -x

    def __init__(self):
        self.nums = []
        self.c = [self.expression() for _ in range(200000)]

    def doit(self, demand):
        i = 100000 - len(self.nums)
        while i &lt; 200000:
            self.c[i] = self.c[i] + demand
            i += self.lowbit(i)

    def append(self, val: int) -&gt; None:
        self.nums.append(val)

    def addAll(self, inc: int) -&gt; None:
        if len(self.nums) == 0:
            return
        demand = self.expression(1, inc)
        self.doit(demand)

    def multAll(self, m: int) -&gt; None:
        if len(self.nums) == 0:
            return
        demand = self.expression(m, 0)
        self.doit(demand)

    def getIndex(self, idx: int) -&gt; int:
        if idx &gt;= len(self.nums):
            return -1
        op = self.expression()
        i = 100000 - idx - 1
        while i &gt;= 1:
            op = op + self.c[i]
            i -= self.lowbit(i)
        return (self.nums[idx] * op.a % self.mod + op.b) % self.mod
</code></pre>
<h2 id="solution-2-multiplicative-inverse-modulomim">Solution 2: Multiplicative inverse modulo(MIM)</h2>
<p>There also existed a more elegant way to solve the problem. If we just use a and b to record all the behaviour, we just need to minus b and divide a before a number adds into the list. But here comes a question, this minus and divide can not be supported under a mod. So we need to use an MIM. MIM can help us use add and multiply to realize minus and divide under a mod: (x / b) % mod = (b ^ (mod - 2) * x) % mod, x - b = (x + mod - b) % mod.. With the two equations, we can solve the problem easily.</p>
<pre><code class="language-python">class Fancy:

    mult = 1
    add = 0
    mod = 10 ** 9 + 7

    def qpow(self, num, power):
        return 1 if power == 0 else self.qpow(num ** 2 % self.mod, power &gt;&gt; 1) % self.mod * (num if power &amp; 1 == 1 else 1)

    def __init__(self):
        self.val = []

    def append(self, val: int) -&gt; None:
        val = (val - self.add + self.mod) * self.qpow(self.mult, self.mod - 2) % self.mod
        self.val.append(val)

    def addAll(self, inc: int) -&gt; None:
        self.add = (self.add + inc) % self.mod

    def multAll(self, m: int) -&gt; None:
        self.mult = self.mult * m % self.mod
        self.add = self.add * m % self.mod

    def getIndex(self, idx: int) -&gt; int:
        return -1 if idx &gt;= len(self.val) else (self.val[idx] * self.mult % self.mod + self.add) % self.mod 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deep Analysis: Count Primes]]></title>
        <id>https://dawn-cmd.github.io/post/Fo59-fr0V/</id>
        <link href="https://dawn-cmd.github.io/post/Fo59-fr0V/">
        </link>
        <updated>2020-12-03T12:45:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="problem-description">Problem Description</h2>
<p>Count the number of prime numbers less than a non-negative number n.</p>
<h2 id="constraints">Constraints:</h2>
<p>0 &lt;= n &lt;= 5 * 10 ^ 6</p>
<h2 id="solution-1-volent-trying">Solution 1: Volent Trying</h2>
<p>So let's see the algorithm with the worst time efficiency. What we need to do is just identifying the integers are primes or not one by one. In the end, we count the number of primes and return the answer. When judging every number, we need to check whether the number from 2 to n - 1 can divide the number we need to judge. If yes, the number is not a prime and in other cases it is a prime.</p>
<pre><code class="language-python">def isprime(num):
    if num == 0 or num == 1:
        return 0
    i = 2
    while i  &lt; num:
        if num % i == 0:
            return 0
        i += 1
    return 1

def main():
    n = int(input())
    ans = 0
    for i in range(n):
        ans += isprime(i)
    print(ans)

main()
</code></pre>
<h2 id="solution-2-a-little-bit-improvement">Solution 2: A little bit improvement</h2>
<p>Let's focus on the function &quot;isprime&quot;. In this function, we try to use [2, n) to divide the number, but actually, we just need [2, sqrt(n) + 1). Because when we try a number larger than sqrt(n) + 1, this process must be repeated before. So we can get this code.</p>
<pre><code class="language-python">def isprime(num):
    if num == 0 or num == 1:
        return 0
    i = 2
    while i ** 2 &lt;= num:  # I did not import Math because it will make the program slow
        if num % i == 0:
            return 0
        i += 1
    return 1

def main():
    n = int(input())
    ans = 0
    for i in range(n):
        ans += isprime(i)
    print(ans)

main()
</code></pre>
<h2 id="solution-3-another-trick">Solution 3: Another trick</h2>
<p>When you judge a number is a prime or not, 6 is a quite efficient number. Why? Because except 2 and 3, if a number n % 6 is neither 1 nor 5, it must not be a prime: 6k + 2 can divide by 2, 6k + 3 can divide by 3, 6k + 4 can divide by 2, 6k + 6 can divde by 6. As a result, we use just one command to cut 2/3 answers. Why it is not efficient?</p>
<pre><code class="language-python">def isprime(num):
    if num == 0 or num == 1:
        return 0
    if num == 2 or num == 3:
        return 1
    elif num % 6 != 1 and num % 6 != 5:
        return 0
    i = 2
    while i ** 2 &lt;= num:
        if num % i == 0:
            return 0
        i += 1
    return 1

def main():
    n = int(input())
    ans = 0
    for i in range(n):
        ans += isprime(i)
    print(ans)

main()
</code></pre>
<h2 id="solution-4-sieve-of-eratosthenes">Solution 4: Sieve of Eratosthenes</h2>
<p>Up to now, it is quite efficient on judging one prime. But we have to judge n numbers. Does there exist better algorithm or not? Of course yes. The Sieve of Eratosthenes can produce the prime from 2 to n - 1 in one time an it is easy to understand: if k is a prime, then k * 2, k * 3, k * 4...... are not primes.</p>
<pre><code class="language-python">def prime_select():
    n = 5 * (10 ** 6) + 1
    h = [1] * n
    h[1] = h[0] = 0
    for i in range(2, n):
        if h[i] == 0:
            continue
        j = i
        while j * i &lt; n:
            h[i * j] = 0
            j += 1
    return h

h = prime_select()

class Solution:
    
    def countPrimes(self, n: int) -&gt; int:
        ans = 0
        for i in range(n):
            ans += h[i]
        return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deep Analysis: Minimum Number of Arrows to Burst Balloons]]></title>
        <id>https://dawn-cmd.github.io/post/guwS0s3Te/</id>
        <link href="https://dawn-cmd.github.io/post/guwS0s3Te/">
        </link>
        <updated>2020-11-25T12:43:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="problem-description">Problem Description</h2>
<p>There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.</p>
<p>Given an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons.</p>
<h2 id="constraints">Constraints</h2>
<p>0 &lt;= points.length &lt;= 104<br>
points[i].length == 2<br>
-2^31 &lt;= xstart &lt; xend &lt;= 2^31 - 1</p>
<h2 id="solution-1-violent-try">Solution 1: Violent Try</h2>
<p>No algorithms! No data structure! Just try all the possibilities. For         each point on x-axis, it has two conditions: has arrow or not. We can          represent it by 0 and 1. Under the most terrible situation, we have 2^        (2^32) possibilities. But it does not matter at all! Because many             excellent solution, algorithms and data structures starts from it.</p>
<pre><code class="language-python">class Solution:
    ans = 2 ** 32 - 1
    def dfs(self, now, end, h):
        if now == end:
            if check(h):
                ans = min(ans, sum(h))
            return
        self.dfs(now + 1, end, h + [0])
        self.dfs(now + 1, end, h + [1])
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int: 
        start = min(list(map(lambda x: x[0], points)))
        end = max(list(map(lambda x: x[1], points)))
        self.dfs(start, end, [])
        return self.ans
</code></pre>
<h2 id="solution-2-greedy-algorithm">Solution 2: Greedy algorithm</h2>
<p>Obviously, we wasted a lot of arrows in the previous trying. So we will try our best to save our arrows. What we do is still judge it from left or right(reverse is okay), but we only use the arrow when we really need it otherwise we have no chance. Let me explain it, for example, there is a balloon is from 5 to 8, and we find position 8 is the last point in its cover. That is to say if we just let it go, we will not be able to shoot the balloon again. So we use the arrow here.</p>
<pre><code class="language-python">class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        ans += 0 
        for i in range(left, right + 1):
            if i is a balloon's right bound:
                # realize a function to shoot a arrow at x[i]
                ans += 1
        return ans        
</code></pre>
<h2 id="solution-3-a-small-improvement">Solution 3: A small improvement</h2>
<p>Up to now, we have build a prototype of the final solution. Let's see whether there is anything can be improved or not. We find that the loop in the previous code has many superfluous visit to irrevelent positions. Because we can see only at the right bound of a balloon, we may do something and the points between two bounds won't be used at all. Self-evidently, we only need to visit the bound points. What's more, we have to visit it by the sequence of its position on x-axis. So we need to sort them with their right bound positions and visit them.</p>
<pre><code class="language-python">class item:
    
    def __init__(self, start, end):
        self.start, self.end = start, end

    def __lt__(self, other):
        return self.end &lt; other.end

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int: 
        p = []
        for i in range(len(points)):
            p.append(item(points[i][0], points[i][1]))
        p.sort()
        ans = 0
        h = [0] * len(p)
        for i in range(len(p)):
            if h[i] == 1:
                continue
            ans += 1
            for j in range(i, len(p)):
                if h[j] == 1:
                    continue
                elif p[j].start &lt;= p[i].end:
                    h[j] = 1
        return ans
</code></pre>
<h2 id="solution-4-a-large-step-to-the-best-one">Solution 4: A large step to the best one</h2>
<p>The solution 3 is excellent enough in most cases, but it is still not stable. In some special cases, the time complexity of the solution will raise to O(n^2). In some restrictedly developing environments, we need a more stable algorithm. Let's see the line 24: when the computer find that this arrow cannot shoot this ballon, it chooses to continue visiting the rest balloons, but it is not necessary. When we find this arrow cannot shoot a balloon for the first time, we can quit the loop. Why? Because if this arrow cannot shoot the balloon, the other arrows will shoot it later, so the following balloons that this arrow can shoot, the other arrows can do it as well.</p>
<pre><code class="language-python">class item:
    
    def __init__(self, start, end):
        self.start, self.end = start, end

    def __lt__(self, other):
        return self.end &lt; other.end

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int: 
        p = []
        for i in range(len(points)):
            p.append(item(points[i][0], points[i][1]))
        p.sort()
        ans = 0
        h = [0] * len(p)
        for i in range(len(p)):
            if h[i] == 1:
                continue
            ans += 1
            for j in range(i, len(p)):
                if h[j] == 1:
                    continue
                elif p[j].start &lt;= p[i].end:
                    h[j] = 1
                else:
                    break
        return ans
</code></pre>
<h2 id="solution-5-make-it-beautiful">Solution 5: Make it beautiful</h2>
<pre><code class="language-python">class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int: 
        points = sorted(points, key = lambda x: x[1])
        ans = 0
        min_end = -2 ** 31 - 1
        for i in points:
            if i[0] &gt; min_end:
                ans += 1
                min_end = i[1]
        return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pairing Heap]]></title>
        <id>https://dawn-cmd.github.io/post/4msqBIkRn/</id>
        <link href="https://dawn-cmd.github.io/post/4msqBIkRn/">
        </link>
        <updated>2020-11-17T13:20:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Well, in the previous passage, we have talked about normal heaps, also called binary heap. In this passage, we will discuss a new kind of heap. It is much more effective than binary heap in many aspects, and it's not hard to practice it as well. Let's see the code first and at the end of the passage, I will compare their efficiency.</p>
<h2 id="code">Code</h2>
<pre><code class="language-python">class node:  # the item class

    def __init__(self, value):
        self.value = value  # value(priority)
        self.bro = self.ch = None  # brother node and child node

class pairing_heap:

    def __init__(self):
        self.root = None  # There is no node
        self.node_number = 0  # It has 0 node

    def __merge(self, a, b):  # Core API 1
        if a is None or b is None:
            return a if b is None else b  # return the one that is not None
        if a.value &gt; b.value:  
            a, b = b, a  # make sure that a is the smaller one
        a.ch, b.bro = b, a.ch  # let b becomes a's child
        return a
        
    def __pair_merge(self, now):  # Core API 2
        if now is None or now.bro is None:  # It has no brother node to break
            return now
        bro1, bro2 = now.bro, now.bro.bro  # save its brother and its brother's brother
        now.bro = bro1.bro = None  # break them
        return self.__merge(self.__merge(now, bro1), self.__pair_merge(bro2))  # merge these two and continue the next two

    def push(self, new):
        if self.root is None:
            self.root = node(new)  # there is no node here, so just let the new one be the root
        else:
            self.root = self.__merge(self.root, node(new))  # consider the new one as a single heap, and merge them
        self.node_number += 1

    def merge(self, new):
        self.root = self.__merge(self.root, new.root)  # just merge the root of the two heap
        self.node_number += new.node_number

    def pop(self):
        if self.root is None:
            return None  # if there is nothing, than it is an error
        self.root = self.__pair_merge(self.root.ch)
        self.node_number -= 1

    def top(self):
        return None if self.root is None else self.root.value
</code></pre>
<h2 id="about-efficiency">About efficiency</h2>
<p>pop: Binary O(nlogn) | Pairing O(h(n))<br>
push: Binary O(nlogn) | Pairing O(1)<br>
get_min: Binary O(1) | Pairing O(1)<br>
merge: Binary doesn't support | Pairing O(1)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Heap]]></title>
        <id>https://dawn-cmd.github.io/post/dENZkdKd3/</id>
        <link href="https://dawn-cmd.github.io/post/dENZkdKd3/">
        </link>
        <updated>2020-11-10T13:53:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Well, let's talk about something simple in this passage. I believe most of you must have learnt pile when you just start to learn data structure. But I will still repeat this part again in this passage because it is quite important for the next passage. If we can really understand the inner system of pile, we will be able to make other algorithms that based on it better as well.</p>
<h2 id="code">Code</h2>
<pre><code class="language-python">class pile:
    def __init__(self):
        self.p = [-1]  # because we use binary tree to actclize the pile, the root node must be 1, so we fill p[0]with -1

    def add(self, x):
        self.p += [x]  # put the number at the end of the pile
        pos = len(self.p) - 1  # locate it 
        while pos &gt; 1:  # when pos is not at root 
            if self.p[pos] &lt; self.p[pos &gt;&gt; 1]:  # pos &gt;&gt; 1(same as pos // 2) is p[pos]'s father node's id
                self.p[pos], self.p[pos &gt;&gt; 1] = self.p[pos &gt;&gt; 1], self.p[pos]  # swap them
                pos &gt;&gt;= 1  # update pos
            else:
                break  # we find a ideal place, so there is no need to go on

    def pop(self):
        if len(self.p) == 1:
            return -1  # there is nothing in the pile, so we return -1 to represent there is something wrong
        if len(self.p) == 2:
            return self.p.pop()  # there is only one element, so we just need to return it and delete it
        ans = self.p[1]  # store the answer
        self.p[1] = self.p.pop()  # replace the place with the last element
        pos = 1
        while pos &lt;&lt; 1 &lt;= len(self.p) - 1:
            if self.p[pos] &gt; self.p[pos * 2]:  # pos &lt;&lt; 1(same as pos * 2) is pos's left son
                self.p[pos], self.p[pos &lt;&lt; 1] = self.p[pos &lt;&lt; 1], self.p[pos]  # swap them
                pos &lt;&lt;= 1  # update pos
                continue
            elif pos &lt;&lt; 1 | 1 &lt;= len(self.p) - 1:  # to ensure pos's right son's id will not exceed the range
                if self.p[pos] &gt; self.p[pos &lt;&lt; 1 | 1]:
                    self.p[pos], self.p[pos &lt;&lt; 1 | 1] = self.p[pos &lt;&lt; 1 | 1], self.p[pos]  # swap them
                    pos = pos &lt;&lt; 1 | 1  # update pos
                    continue
                else:
                    break
            else:
                break
        return ans

def main():
    a = list(map(int, input('elements:').split())) # input the data
    n = len(a)
    pl = pile()
    for i in range(len(a)):
        pl.add(a[i])  # put all the things into pile and they will be sorted automatically :)
    print('sorted:', end = '')
    for i in range(n):
        print(pl.pop(), end = '\n' if i == n - 1 else ' ')  # output the answer

main()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prim & Kruskal]]></title>
        <id>https://dawn-cmd.github.io/post/cLmXwc5OE/</id>
        <link href="https://dawn-cmd.github.io/post/cLmXwc5OE/">
        </link>
        <updated>2020-11-03T13:18:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Today let's talk about Minimum Spanning Tree (MST) problem. In  a MST problem, you usually have n points, and what you need to do is to use or choose n - 1 edges to connect them and minimize the sum of the length of the edges. There exist two basic algorithms to solve it: Kruskal and Prim. Both of them are adapted from the Greedy Algorithm and Kruskal considers edges as units while Prim considers points as units. I will show how they realize and explain them in the following code.</p>
<h2 id="code">Code</h2>
<h3 id="kruskal">Kruskal</h3>
<pre><code class="language-python">#Kruskal is better when the egdes are less than points, which means it is a sparse graph
class edge:
    fr = 0 #from
    to = 0 #to
    c = 0 #cost
    def __init__(self, fr, to, c):
        self.fr = fr
        self.to = to
        self.c = c
    def __lt__(self, oth):
        return self.c &lt; oth.c #reload '&lt;'

class dsuf:#disjoint sets/union find
    fa = [0]
    def __init__(self, n):
        self.fa *= n + 1
        for i in range(n + 1):
            self.fa[i] = i#if we find fa[x] == x then x is a source point
    def merge(self, a, b):
        self.fa[self.find(b)] = a# let a becomes b's father
    def find(self, a):
        if a == self.fa[a]:
            return a
        self.fa[a] = self.find(self.fa[a]) #compress the path to decrease the depth of tree
        return self.fa[a]

def kruskal(e, n, u):
    ans = 0
    for i in e:#pick egdes in order of cost
        if u.find(i.to) == u.find(i.fr):#check the two vertexs are in a same union or not
            continue
        ans += i.c #you can use an array to record all of them as well
        u.merge(i.to, i.fr)
    return ans

def main():
    n, m = map(int, input().split())#input the number of edge and vertexs
    e = []
    u = dsuf(n)
    for i in range(m):#input edges
        fr, to, c = map(int, input().split())
        e += [edge(fr, to, c)]
    e.sort()#sort edges by their cost
    print(kruskal(e, n, u))

main()
</code></pre>
<h3 id="prim">Prim</h3>
<pre><code class="language-python"># Prim is better when the points in graph is more than edges in the graph
import queue

class point:
    x = y = -1
    def __init__(self, pos):
        self.x = pos[0]
        self.y = pos[1]
    def dis(self, other):
        return (self.x - other.x) ** 2 + (self.y - other.y) ** 2# the distance between two points

def prim(p, c):
    ans = 0
    q = queue.PriorityQueue() # use priority_queue to make it better
    q.put([0, 0])
    h = {}
    for i in range(len(p)):
        h[i] = 0#to record whether it has been visited or not
    while not q.empty():
        now = q.get()
        if h[now[1]] == 1:
            continue# if the point has already been visited, ignore it
        h[now[1]] = 1
        ans += now[0]
        for i in range(len(p)):
            if h[i] == 0 and p[now[1]].dis(p[i]) &gt;= c:#you can eliminate the second limitaion when you use it
                q.put((p[now[1]].dis(p[i]), i))
    for i in range(len(p)):
        if h[i] == 0:
            return -1# you can ignore this loop as well
    return ans

def main():
    n, c = map(int, input().split()) # n is number of points, c is a limitaiton when I was doing a test, you can ignore it
    p = []
    for i in range(n):
        p += [point(list(map(int, input().split())))]
    print(prim(p, c))

main()
</code></pre>
<h2 id="moreover">Moreover</h2>
<p>The two main stream algorithms can be adapted into different versions to cope with different problems. We may talk about it in the other passages.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Segment Tree]]></title>
        <id>https://dawn-cmd.github.io/post/lGXuyC3uR/</id>
        <link href="https://dawn-cmd.github.io/post/lGXuyC3uR/">
        </link>
        <updated>2020-10-26T12:57:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Segment Tree, as its name, store information about periods of segment, like the maximum and minimum of the sequence, in all vertexs of the tree. Sepcifically, it looks like this:</p>
<figure data-type="image" tabindex="1"><img src="https://dawn-cmd.github.io/post-images/1603719518361.png" alt="" loading="lazy"></figure>
<p>But, well, you may ask: why we need to use about 4 times space to split the sequence into these small parts? It is because you can find, if you rebuild sequence into the binary tree, all the things we need to do with the element one by one, like add x to all elements with id from 0 ~ 9, just need few steps on segment tree. I will explain all these functions and how they work in my following codes.</p>
<h2 id="code">Code</h2>
<h3 id="python">Python</h3>
<pre><code class="language-python">class SMT: #Segment Tree stores information about maximum 
    __data = [0]# maximum of the elements
    __l = [0]# left range of the vertexs
    __r = [0]# right range of the vertexs
    def __build(self, pos, a, l, r):#build the tree
        self.__r[pos] = r
        self.__l[pos] = l
        if l == r:
            self.__data[pos] = a[l]# when there is only one element, the maximum number is itself
            return
        mid = (l + r) &gt;&gt; 1#the position to divide the two children of the vertex
        self.__build(pos &lt;&lt; 1, a, l, mid)
        self.__build(pos &lt;&lt; 1 | 1, a, mid + 1, r)
        self.__data[pos] = max(self.__data[pos &lt;&lt; 1], self.__data[pos &lt;&lt; 1 | 1])
    def __init__(self, a):
        self.__data *= len(a) * 4 + 1
        self.__r *= len(a) * 4 + 1
        self.__l *= len(a) * 4 + 1
        self.__build(1, a, 0, len(a) - 1)
    def add(self, pos, l, r, x):
        if l == r:
            self.__data[pos] += x
            return
        mid = (self.__l[pos] + self.__r[pos]) &gt;&gt; 1
        if r &lt;= mid:
            self.add(pos &lt;&lt; 1, l, r, x)
        elif l &gt;= mid + 1:
            self.add(pos &lt;&lt; 1 | 1, l, r, x)
        else:
            self.add(pos &lt;&lt; 1, l, mid, x)
            self.add(pos &lt;&lt; 1 | 1, mid + 1, r, x)
        self.__data[pos] = max(self.__data[pos &lt;&lt; 1], self.__data[pos &lt;&lt; 1 | 1])
    def maximum(self, pos, l, r):
        if l &lt;= self.__l[pos] and r &gt;= self.__r[pos]:
            return self.__data[pos]
        ans = -2147483647
        mid = (self.__l[pos] + self.__r[pos]) &gt;&gt; 1
        if l &gt;= mid + 1:
            ans = max(ans, self.maximum(pos &lt;&lt; 1 | 1, l, r))
        elif r &lt;= mid:
            ans = max(ans, self.maximum(pos &lt;&lt; 1, l, r))
        else:
            ans = max(self.maximum(pos &lt;&lt; 1 | 1, l, mid), self.maximum(pos &lt;&lt; 1 | 1, mid + 1, r))
        return ans
def main():
    a = list(map(int, input().split()))
    tree = SMT(a)
    while 1:
        command = input()
        if command == 'add':# add x to all elements with id from l to r
            l, r, x = map(int, input().split())
            tree.add(1, l, r, x)
        elif command == 'max':
            l, r = map(int, input().split())#print the maximum number from l to r
            print(tree.maximum(1, l, r))
main()
</code></pre>
<h3 id="c">C++</h3>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
#define LL long long
using namespace std;
int n;
int T;
int MOD;
LL a[100010];
struct tr{
    int l;
    int r;
    LL pt;
    LL mt;
    LL d;
    #define l(x) st[x].l
    #define r(x) st[x].r
    #define pt(x) st[x].pt
    #define mt(x) st[x].mt
    #define d(x) st[x].d
};
tr st[1000010];
void build(int now,int l,int r){
    l(now)=l;
    r(now)=r;
    pt(now)=0;
    mt(now)=1;
    if(l==r){
        d(now)=a[l]%MOD;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(now&lt;&lt;1,l,mid);
    build(now&lt;&lt;1|1,mid+1,r);
    d(now)=d(now&lt;&lt;1)+d(now&lt;&lt;1|1);
    return;
}
void push_down(int now){
    d(now&lt;&lt;1)=(d(now&lt;&lt;1)*mt(now)%MOD+pt(now)*(r(now&lt;&lt;1)-l(now&lt;&lt;1)+1)%MOD)%MOD;
    d(now&lt;&lt;1|1)=(d(now&lt;&lt;1|1)*mt(now)%MOD+pt(now)*(r(now&lt;&lt;1|1)-l(now&lt;&lt;1|1)+1)%MOD)%MOD;
    pt(now&lt;&lt;1)=(pt(now&lt;&lt;1)*mt(now)%MOD+pt(now))%MOD;
    pt(now&lt;&lt;1|1)=(pt(now&lt;&lt;1|1)*mt(now)%MOD+pt(now))%MOD;
    mt(now&lt;&lt;1)=mt(now&lt;&lt;1)*mt(now)%MOD;
    mt(now&lt;&lt;1|1)=mt(now&lt;&lt;1|1)*mt(now)%MOD;
    !mt(now&lt;&lt;1)?mt(now&lt;&lt;1)=MOD:0;
    !mt(now&lt;&lt;1|1)?mt(now&lt;&lt;1|1)=MOD:0;
    pt(now)=0;
    mt(now)=1;
}
void add(int now,int l,int r,int p){
    if(l&lt;=l(now)&amp;&amp;r&gt;=r(now)){
        d(now)=(d(now)+p*(r(now)-l(now)+1)%MOD)%MOD;
        pt(now)=(pt(now)+p)%MOD;
        return;
    }
    if(pt(now)||mt(now)&gt;1){
        push_down(now);
    }
    int mid=(l(now)+r(now))&gt;&gt;1;
    if(l&lt;=mid){
        add(now&lt;&lt;1,l,r,p);
    }
    if(r&gt;mid){
        add(now&lt;&lt;1|1,l,r,p);
    }
    d(now)=d(now&lt;&lt;1)+d(now&lt;&lt;1|1);
    return;
}
void mul(int now,int l,int r,int p){
    if(l&lt;=l(now)&amp;&amp;r&gt;=r(now)){
        d(now)=d(now)*p%MOD;
        pt(now)=pt(now)*p%MOD;
        mt(now)=mt(now)*p%MOD;
        return;
    }
    if(pt(now)||mt(now)&gt;1){
        push_down(now);
    }
    int mid=(l(now)+r(now))&gt;&gt;1;
    if(l&lt;=mid){
        mul(now&lt;&lt;1,l,r,p);
    }
    if(r&gt;mid){
        mul(now&lt;&lt;1|1,l,r,p);
    }
    d(now)=d(now&lt;&lt;1)+d(now&lt;&lt;1|1);
    return;
}
LL sum(int now,int l,int r){
    if(l&lt;=l(now)&amp;&amp;r&gt;=r(now)){
        return d(now);
    }
    if(pt(now)||mt(now)&gt;1){
        push_down(now);
    }
    int mid=(l(now)+r(now))&gt;&gt;1;
    int ans=0;
    l&lt;=mid?ans=(ans+sum(now&lt;&lt;1,l,r))%MOD:0;
    r&gt;mid?ans=(ans+sum(now&lt;&lt;1|1,l,r))%MOD:0;
    return ans;
}
int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin&gt;&gt;n&gt;&gt;T&gt;&gt;MOD;
    for(int i=1;i&lt;=n;++i){
        cin&gt;&gt;a[i];
    }
    build(1,1,n);
    int k;
    int x;
    int y;
    int z;
    while(T--){
        cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;
        if(k==1){
            cin&gt;&gt;z;
            mul(1,x,y,z);
        }
        else if(k==2){
            cin&gt;&gt;z;
            add(1,x,y,z);
        }
        else{
            cout&lt;&lt;sum(1,x,y)&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>
<h2 id="whats-more">What's more</h2>
<p>Although the data structure is quite plastic, it is a little bit hard to realize sepecially when you try to integrate many functions into one segment tree. So I suggests that when you try to make more than one function, use a segment tree to finish a sepcific funtion. And if the function is just concern about the sum of a sequence, you can use binary indexed tree because it is much easier to be finished than segment tree.</p>
]]></content>
    </entry>
</feed>