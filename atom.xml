<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dawn-cmd.github.io</id>
    <title>Blog</title>
    <updated>2021-04-18T01:03:22.701Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dawn-cmd.github.io"/>
    <link rel="self" href="https://dawn-cmd.github.io/atom.xml"/>
    <subtitle>People who know nothing repeat it.
</subtitle>
    <logo>https://dawn-cmd.github.io/images/avatar.png</logo>
    <icon>https://dawn-cmd.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Blog</rights>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #715 (Div. 2) Problem B]]></title>
        <id>https://dawn-cmd.github.io/post/codeforces-round-715-div-2-problem-b/</id>
        <link href="https://dawn-cmd.github.io/post/codeforces-round-715-div-2-problem-b/">
        </link>
        <updated>2021-04-18T00:29:43.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://dawn-cmd.github.io/post-images/1618705814373.png" alt="" loading="lazy"></figure>
<h2 id="introduction">Introduction</h2>
<p><a href="https://codeforces.com/contest/1509/problem/B">Raw Link</a><br>
The student council has a shared document file. Every day, some members of the student council write the sequence TMT (short for Towa Maji Tenshi) in it.</p>
<p>However, one day, the members somehow entered the sequence into the document at the same time, creating a jumbled mess. Therefore, it is Suguru Doujima's task to figure out whether the document has malfunctioned. Specifically, he is given a string of length n whose characters are all either T or M, and he wants to figure out if it is possible to partition it into some number of disjoint subsequences, all of which are equal to TMT. That is, each character of the string should belong to exactly one of the subsequences.</p>
<p>A string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero) characters.</p>
<h2 id="input-form">Input Form</h2>
<p>The first line contains an integer t (1 ≤ t ≤ 5000)  — the number of test cases.</p>
<p>The first line of each test case contains an integer n (3 ≤ n &lt; 10^5), the number of characters in the string entered in the document. It is guaranteed that n is divisible by 3.</p>
<p>The second line of each test case contains a string of length n consisting of only the characters T and M.</p>
<p>It is guaranteed that the sum of n over all test cases does not exceed 10^5.</p>
<h2 id="output-form">Output Form</h2>
<p>For each test case, print a single line containing <code>YES</code> if the described partition exists, and a single line containing <code>NO</code> otherwise.</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct Data {
    int n;
    string s;
    int m_num;
    int t_num;
};
void init(Data &amp;d) {
    cin &gt;&gt; d.n;
    cin &gt;&gt; d.s;
    d.m_num = 0;
    d.t_num = 0;
}
int main() {
    int t;
    cin &gt;&gt; t;
    while(t--) {
        Data d;
        init(d);
        bool ans = 1;
        for(int i = 0; i &lt; d.s.size(); ++i) {
            if(d.s[i] == 'M') {
                d.m_num += 1;
            }
            else{
                d.t_num += 1;
            }
            if(d.m_num &gt; d.t_num) {
                ans = 0;
                break;
            }
        }
        if(!ans) {
            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
            continue;
        }
        d.m_num = 0;
        d.t_num = 0;
        for(int i = d.s.size() - 1; i &gt;= 0; --i) {
            if(d.s[i] == 'M') {
                d.m_num += 1;
            }
            else{
                d.t_num += 1;
            }
            if(d.m_num &gt; d.t_num) {
                ans = 0;
                break;
            }
        }
        if(d.m_num * 2 != d.t_num) {
            ans = 0;
        }
        if(!ans) {
            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        }
        else{
            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
<h2 id="explanation">Explanation</h2>
<p>If we translate the problem, we will find that all the requirements turns into two rules:</p>
<ol>
<li>Check the string from left to right and right to left, the number of M should not exceed the number of T at any time.</li>
<li>The number of T should be the double of number of M</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #715 (Div. 2) Problem A]]></title>
        <id>https://dawn-cmd.github.io/post/codeforces-round-715-div-2-problem-a/</id>
        <link href="https://dawn-cmd.github.io/post/codeforces-round-715-div-2-problem-a/">
        </link>
        <updated>2021-04-17T00:43:09.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://dawn-cmd.github.io/post-images/1618620382440.png" alt="" loading="lazy"></figure>
<h2 id="introduction">Introduction</h2>
<p><a href="https://codeforces.com/contest/1509/problem/A">Raw Link</a><br>
Sayaka Saeki is a member of the student council, which has n other members (excluding Sayaka). The i-th member has a height of ai millimeters.</p>
<p>It's the end of the school year and Sayaka wants to take a picture of all other members of the student council. Being the hard-working and perfectionist girl as she is, she wants to arrange all the members in a line such that the amount of photogenic consecutive pairs of members is as large as possible.</p>
<p>A pair of two consecutive members u and v on a line is considered photogenic if their average height is an integer, (u + v) / 2 is an integer.</p>
<p>Help Sayaka arrange the other members to maximize the number of photogenic consecutive pairs.</p>
<h2 id="input-form">Input Form</h2>
<p>The first line contains a single integer t (1≤t≤500) — the number of test cases.</p>
<p>The first line of each test case contains a single integer n (2≤n≤2000)  — the number of other council members.</p>
<p>The second line of each test case contains n integers a1, a2, ..., an (1≤ai≤2⋅10^5)  — the heights of each of the other members in millimeters.</p>
<p>It is guaranteed that the sum of n over all test cases does not exceed 2000.</p>
<h2 id="output-form">Output Form</h2>
<p>For each test case, output on one line n integers representing the heights of the other members in the order, which gives the largest number of photogenic consecutive pairs. If there are multiple such orders, output any of them.</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct Data {
    int n;
    vector&lt;int&gt; h_odd;
    vector&lt;int&gt; h_even;
};
void init(Data &amp;d) {
    cin &gt;&gt; d.n;
    for(int i = 0; i &lt; d.n; ++i) {
        int tmp;
        cin &gt;&gt; tmp;
        if(tmp &amp; 1) {
            d.h_odd.push_back(tmp);
        }
        else{
            d.h_even.push_back(tmp);
        }
    }
}
int main() {
    int t;
    cin &gt;&gt; t;
    while(t--) {
        Data d;
        init(d);
        for(auto i : d.h_odd) {
            cout &lt;&lt; i &lt;&lt; ' ';            
        }
        for (auto i : d.h_even) {
            cout &lt;&lt; i &lt;&lt; ' '; 
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h2 id="explanation">Explanation</h2>
<p>Obviously, if a consecutive pair of members is considered photogenic, their heights must be all odd or even, otherwise u + v cannot divided by 2 with a integer. Hence, we just need to do is to make sure that all men with odd heights were stand together, even as well.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Luogu P2196 [NOIP1996 senior] Dig Landmines]]></title>
        <id>https://dawn-cmd.github.io/post/luogu-p2196-noip1996-senior-dig-landmines/</id>
        <link href="https://dawn-cmd.github.io/post/luogu-p2196-noip1996-senior-dig-landmines/">
        </link>
        <updated>2021-04-15T23:26:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p><a href="https://www.luogu.com.cn/problem/P2196">Raw Link</a><br>
There are N cellars (N≤20) on a map, and a certain number of mines are buried in each cellar. At the same time, give the connection path between the cellars. After the data of the cellar and its connection are given, someone can start digging mines from any place, and then dig down along the indicated connection (only one path can be selected), and the mine digging work ends when there is no connection. Design a plan for digging mines so that someone can dig the most mines.</p>
<h2 id="input-form">Input Form</h2>
<p>There are several lines.</p>
<p>There is only one number in the first line, which represents the number of cellars N.</p>
<p>There are N numbers in the second line, which respectively indicate the number of mines in each cellar.</p>
<p>Lines 3 to N+1 indicate the connection between the cellars:</p>
<p>There are n−1 numbers (0 or 1) in the third row, indicating whether there is a path connection from the first cellar to the second, third, ..., nth cellar. For example, the third line is 11000...0, it means that there is a path from the first cellar to the second cellar, there is a path to the third cellar, and there is no path to the fourth cellar, the fifth, ..., the nth cellar.</p>
<p>There are n−2 numbers in the 4th row, indicating whether there is a path connection from the second cellar to the third, fourth, ..., nth cellar.</p>
<p>There is 1 number in the n+1th row, indicating whether there is a path connection between the n−1th cellar and the nth cellar. (0 means there is no path, 1 means there is a path).</p>
<h2 id="output-form">Output Form</h2>
<p>There are two lines</p>
<p>The first line indicates the order of mine digging when the most mines are dug. The serial numbers of each cell are separated by a space, and there must be no extra spaces.</p>
<p>There is only one number in the second row, indicating the maximum number of mines that can be dug.</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
void init(int &amp;n, int (&amp;g)[50][50], int (&amp;v)[50], int sum) {
    cin &gt;&gt; n;
    for(int i =1; i &lt;= n; ++i) {
        cin &gt;&gt; v[i];
    }
    for(int i = 1; i &lt;= n - 1; ++i)
        for(int j = i + 1; j &lt;= n; ++j){
            int tmp;
            cin &gt;&gt; tmp;
            g[i][j] = tmp;
        }
    for(int i = 1; i &lt;= n; ++i) {
        g[0][i] = 1;
    }
    v[0] = 0;
}
struct Data {
    int h[50];
    int g[50][50];
    int v[50];
    int n;
    int sum = 0;
    int max_sum = -1;
    vector&lt;int&gt; path;
    vector&lt;int&gt; ans_path;
};
int dp(int now, Data &amp;data) {
    if(data.h[now] == 1) {
        return 0;
    }
    data.h[now] = 1;
    int maxn = -1;
    data.sum += data.v[now];
    data.path.push_back(now);
    for (int i = 1; i &lt;= data.n; ++i) {
        if(data.g[now][i] == 0 || i == now || data.h[i] == 1) {
            continue;
        }
        int tmp = dp(i, data);
        maxn = max(maxn, tmp);
    }
    if(maxn == -1 &amp;&amp; data.sum &gt; data.max_sum) {
        data.max_sum = data.sum;
        data.ans_path = data.path;
    }
    data.sum -= data.v[now];
    data.h[now] = 0;
    data.path.pop_back();
    return data.v[now] + max(maxn, 0);
}
int main() {
    Data data;
    init(data.n,data.g,data.v, data.sum);
    int ans = dp(0, data);
    for(int i = 1; i &lt; data.ans_path.size(); ++i) {
        cout &lt;&lt; data.ans_path[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2 id="explanation">Explanation</h2>
<ol>
<li>It has the characteristics of graph theory.</li>
<li>The data range is very small (N \le 20) (N ≤ 20), and you can make &quot;exotic&quot; attempts.</li>
<li>It is necessary to output the route and the maximum solution result, which can be combined to reduce the amount of code.</li>
<li>Use pre to record the predecessor of the selected point in the reasonable scheme, and recursively output. (You can also use a while loop, given in the next method)</li>
<li>Obviously it is impossible to find the answer simply, so the state is designed to facilitate the transfer. Let f[i]f[i] represent the maximum number of mines dug from the starting point to the point ii. When i and j are connected, f[j ] (Another point, enumerate it) When the maximum value is reached, the recursive formula f[i]=max(f[j])+mine<a href="map%5Bj,i%5D=1">i</a> is obtained.</li>
<li>Be sure to note the last point on the path to output it recursively.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Luogu P1216 Number Triangles]]></title>
        <id>https://dawn-cmd.github.io/post/luogu-p1216-number-triangles/</id>
        <link href="https://dawn-cmd.github.io/post/luogu-p1216-number-triangles/">
        </link>
        <updated>2021-04-15T15:54:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p><a href="https://www.luogu.com.cn/problem/P1216">Raw Link</a><br>
Write a program to find the path from the highest point to the bottom anywhere, so that the path passes through the largest sum of numbers. Each step can go to the bottom left point or the bottom right point.<br>
7<br>
3   8<br>
8   1   0<br>
2   7   4   4<br>
4   5   2   6   5<br>
In the above example, the path from 7→3→8→7→7→3→8→7→5 produces the largest one.</p>
<h2 id="input-form">Input Form</h2>
<p>The first line is a positive integer rr, which indicates the number of lines.</p>
<h2 id="output-form">Output Form</h2>
<p>A single line containing the largest sum possible.</p>
<h2 id="notice">Notice</h2>
<p>For 100% data,1≤r≤1000, all inputs are in the range of [0,100].</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() {
    int r;
    cin &gt;&gt; r;
    vector&lt;vector&lt;int&gt;&gt; graph(r);
    for (int i = 0; i &lt; r; ++i) {
        graph[i] = vector&lt;int&gt;(i + 1);
        for (int j = 0; j &lt; i + 1; ++j) 
            cin &gt;&gt; graph[i][j];
    }
    vector&lt;vector&lt;int&gt;&gt; dp(r);
    for (int i = 0; i &lt; r; ++i)
        for (int j = 0; j &lt; i + 1; ++j) 
            dp[i].push_back(0);
    dp[0][0] = graph[0][0];
    for (int i = 1; i &lt; r; ++i)
        for (int j = 0; j &lt; i + 1; ++j) {
            if (j == 0) {
                dp[i][j] = dp[i - 1][j] + graph[i][j];
                continue;
            }
            if (j == i) {
                dp[i][j] = dp[i - 1][j - 1] + graph[i][j];
                continue;
            }
            dp[i][j] = graph[i][j] + max(dp[i - 1][j], dp[i - 1][j - 1]);
        }
    int ans = 0;
    for (int i = 0; i &lt; r; ++i)
        ans = max(ans, dp[r - 1][i]);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2 id="explanation">Explanation</h2>
<p>This question is a dp introductory mention in many textbooks, and the idea is that it is a naked dp.</p>
<p>Let f[i][j] represent the maximum sum from (1,1) to (i,j), then f[i][j]=max(f[i-1][j],f[i- 1][j-1])+a[i][j] Because the point (i,j) can only come from two points (i-1,j) and (i-1,j-1), So take the maximum of the two of them + the number at this point.</p>
<p>In fact, the dp array f of this question can be optimized to O(n), but it doesn't make much sense: the first will not exceed the memory anyway, and the second a must already be two-dimensional. In fact, the a array can also be optimized as a one-dimensional, but it won't exceed the memory anyway, just ignore it.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introduction of Dynamic Programming]]></title>
        <id>https://dawn-cmd.github.io/post/introduction-of-dynamic-programming/</id>
        <link href="https://dawn-cmd.github.io/post/introduction-of-dynamic-programming/">
        </link>
        <updated>2021-04-10T01:05:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="about-this-article">About this article</h2>
<p>This time let's talk about a critical part of algorithm: Dynamic Programming(DP). Actually, I wanted to write about it for a long time. However, its complexity makes me cannot start writing until now. Cause instead of a specific method, DP is more like a system of methods, or a special angle to see the problems. This time we will introduce DP in general and unfold each specific point in the future.</p>
<h2 id="basic-introduction">Basic introduction</h2>
<p>We often see problems that seems periodic or consisted of several similar sub-problems are hard to solve directly, like the famous Fibonacci Sequence. Although we all know that the sequence has a direct function, most people are more familiar with this: f(n) = f(n - 1) + f(n - 2), which is more clear and practicable. This is a typical example of DP, which has direct <code>&quot;optimal substructures&quot;</code> and <code>&quot;recursive sub-problems&quot;</code>. &quot;Optimal substructure&quot; means the optimal solution of this problem can totally inferred from its subproblems optimal solutions. &quot;Recursive subproblems&quot; means the problem itself is similar to its subproblems in general.</p>
<h2 id="common-structure">Common structure</h2>
<p>Before we actually practice it in problems, we need to understand the common steps to make sure we have a clear direction.</p>
<p>All DP solutions are consisted of three parts: <code>Level</code>, <code>State</code>, and <code>State Transformation Functions</code>:</p>
<ul>
<li>
<p>Level: The basic unit we want to divide the problem into. In Fibonacci Sequence problem, each position in the sequence is the level we define. Interestingly, many problems have several different DP solution depended on the choice of level, and the time compexity and difficulty of practicing will change as well.</p>
</li>
<li>
<p>State: Specific data the level has. In equations, we often use varibles like i, j, and k to represent state. Yet in some special situations, the state will give a answer that does not follow the other's rule, for example, the border limitation.</p>
</li>
<li>
<p>State Transformation Function: The core function of a DP solution. It directly represents how optimal solution of the problem can be inferred from the optimal solutions of its subproblems.</p>
</li>
</ul>
<h2 id="example-fibonacci-sequence">Example: Fibonacci Sequence</h2>
<p>In this example, I will show two basic methods of actualizing DP.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int dp(int k) {
    if(k == 0) return 0;
    if(k == 1) return 1;
    return dp(k - 1) + dp(k - 2);
} 
int main() {
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; dp(n) &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>The first way, just showed above, is using a function to imitate the process. However, obviously it is an ineffective way because there exist too many repeated steps. Of course there are ways to solve it, but let's see the next method first.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() {
    int n;
    cin &gt;&gt; n;
    vector&lt;long long&gt; dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for(int i = 2; i &lt;= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    cout &lt;&lt; dp[n] &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>The next way is using a array to imitate the solution. It seems faster than the previous method. But it has a fatal shortcoming: you must make sure that the state will increase or decrease in a fixed direction. Otherwise you cannot use this method.</p>
<h2 id="the-end">The end</h2>
<p>So this is the end of the introduction. Of course, it is just a beginning of this series. DP is an interesting subject to study. It can also be used in mathmatics, biology, economic and so on.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Manacher]]></title>
        <id>https://dawn-cmd.github.io/post/ntYB0fMZm/</id>
        <link href="https://dawn-cmd.github.io/post/ntYB0fMZm/">
        </link>
        <updated>2021-02-17T02:31:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>Manacher algorithm can be used in most palindrome string problems. It provides a solution with O(n) time complexity.</p>
<h2 id="sample-problem">Sample problem</h2>
<p><a href="https://www.luogu.com.cn/problem/P3805">LuoguP3805</a><br>
Give you a string S. Calculate the length of the longest palindrome substring in it.<br>
1 &lt; length &lt; 1.1e7</p>
<h2 id="solution-1">Solution 1:</h2>
<p>Try every subtring and scan all of them to update the answer. Because we enumerate the left bound and right bound and check each character in the substring. Its time complexity is O(n^3). Actually, it is far from optimal condition.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
bool check(int st, int ed, string s) {
    while (st &lt;= ed) {
        if (s[st] != s[ed]) return 0;
        st++, ed--;
    }
    return 1;
}
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    string s;
    cin &gt;&gt; s;
    int ans = -1;
    for (int i = 0, l = s.size(); i &lt; l; ++i) {
        for (int j = i; j &lt; l; ++j) {
            if (check(i, j, s)) ans = max(ans, j - i + 1);
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dawn-cmd.github.io/post-images/1613568323104.png" alt="" loading="lazy"></figure>
<h2 id="solution-2">Solution 2:</h2>
<p>Let's try to improve it. After observation, we find that we can enumerate the mid point of the palindrome string. Then expand until it touch its bound. The time complexity will become O(n^2), much faster. However, sometimes the mid point is between two characters. If we deal with the strings with odd number of characters and even number of characters separately, the code will become tedious. Using &quot;temp character&quot; can solve it elegantly. We can fill '#' (or some other characters that does not exist in the string) in the position between characters to simplify the code.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
string change (string s) {
    string ans = &quot;+#&quot;;
    for (auto &amp;i: s) {
        ans += i;
        ans += '#';
    }
    ans += &quot;-&quot;;
    return ans;
}
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    string s;
    cin &gt;&gt; s;
    s = change(s);
    int ans = -1;
    for (int i = 1, len = s.size() - 1; i &lt; len; ++i) {
        int tmp = 0;
        while (s[i + tmp + 1] == s[i - tmp - 1]) ++tmp;
        ans = max(ans, tmp);
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://dawn-cmd.github.io/post-images/1613614637904.png" alt="" loading="lazy"></figure>
<p>As we see, it really made some progress. But still cannot satisfy the need.</p>
<h2 id="solution-3">Solution 3</h2>
<p>Here comes our leading role, the manacher algorithm. In fact, its core idea is quite easy to understand:<br>
<img src="https://dawn-cmd.github.io/post-images/1613615453237.png" alt="" loading="lazy"><br>
When you find a palindrome string in the half of another palindrome, it is obvious that there exist a totally same palindrome at the symmetry position. When we meet this situation, we can give the length of the palindrome in O(1).</p>
<p>So we can maximize this idea. We choose the largest palindrome string that reach the most far position as the base palindrome and record its mid point and right bound (because we just need these, we call them max_right and max_mid in the following passage). When the mid point i's id is small than max_right, we can immediately know its radius is at least radius[mid * 2 - i].</p>
<p>But here is a point, why we use &quot;at least&quot; but not &quot;exactly is&quot;? Sometimes i + radius[i] may touch max_right and the excceeding part will not follow the role, so we need update. Moreover, when this happen, we need to update max_right and max_mid as well.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
string change (string base) {
    string ans = &quot;+#&quot;;
    for (auto &amp;i: base) {
        ans += i;
        ans += '#';
    }
    ans += &quot;-&quot;;
    // The string will be in the form like &quot;+#a#b#c#-&quot;. Adding '#' between characters
    // can help us standardize strings with odd length and even length. The '+' and '-'
    // are marks of ending that can help us end loops easily. I will explain it in detail later.
    return ans;
}
void manacher (string &amp;s, vector &lt;int&gt; &amp;p) {
    int max_right = 0;  // the right bound we have calculated
    int max_mid = 0;  // the mid point of the largest palindrome string that contains max_right
    for (int i = 1, l = s.size(); i &lt; l; ++i) {
        p[i] = i &lt;= max_right  // if i is still in range
               ? min(max_right - i, p[(max_mid &lt;&lt; 1) - i])  // we can use its bro's data directly
               : 0;  // otherwise, we can just calculate it from beginning
        while (s[i + p[i] + 1] == s[i - p[i] - 1]) ++p[i];  // expand the length, the loop will end automacally.
        if (max_right &lt; i + p[i]) max_right = i + p[i], max_mid = i;  // update max_right and max_mid
    }
    return;
}
int main () {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    string s;
    cin &gt;&gt; s;
    s = change(s);  // pretreatment
    vector &lt;int&gt; p (s.size());  // p[i] means the radius of the palindrome string with a mid point at i (exclude i itself).
    manacher(s, p);
    int ans = -1;
    for(int i = 0, l = p.size(); i &lt; l; ++i) {
        ans = max(ans, p[i]);  
        // Cause we have pretreated s, its length is 2 times larger than before.
        // So, p[i] itself represents the actually length of its palindrome string.
        // But not the radius.
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://dawn-cmd.github.io/post-images/1613638344217.png" alt="" loading="lazy"></figure>
<h2 id="about-time-complexity">About time complexity</h2>
<p>This algorithm is O(n): when i cannot update max_right, we can get the answer in O(1); when i can update max_right, we need O(n) to update it.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Circle-Based Tree]]></title>
        <id>https://dawn-cmd.github.io/post/5vxYJM5Nd/</id>
        <link href="https://dawn-cmd.github.io/post/5vxYJM5Nd/">
        </link>
        <updated>2021-01-31T02:58:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="basic-definition-two-main-principle">Basic Definition &amp; Two Main Principle</h2>
<p>Just like zero point is not a point, circle-based tree is not a tree as well.<br>
Circle-based Tree, a graph with n vertexs and n edges, has one or more circles in it.</p>
<figure data-type="image" tabindex="1"><img src="https://dawn-cmd.github.io/post-images/1612143955427.png" alt="" loading="lazy"></figure>
<p>The graph has only one circle when the whole graph is connected. In other cases, it will form a &quot;Circle-Based Forest&quot;.</p>
<figure data-type="image" tabindex="2"><img src="https://dawn-cmd.github.io/post-images/1612143997831.png" alt="" loading="lazy"></figure>
<p>When we deal with problems relate to it, we can follow two main idea:</p>
<ul>
<li>Refine the circle from graph, then the graph will be like that some child - trees hang on the circle. Process the data on child-trees and return data to vertexs on circle. Finally, solve the circle problem.</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://dawn-cmd.github.io/post-images/1612144344053.png" alt="" loading="lazy"></figure>
<ul>
<li>Choosing to overlook an edge is also a direction. If we ignore an edge in the graph, it will become a simple tree.</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://dawn-cmd.github.io/post-images/1612146199022.png" alt="" loading="lazy"></figure>
<h2 id="practise">Practise</h2>
<h3 id="cf711d">CF711D</h3>
<ul>
<li>
<p>Describe:<br>
Give you a graph with n edges without directions and n vertexs. You can define every edge's direction. Calculate there are how many solutions that can let the graph have no circle.</p>
</li>
<li>
<p>Solution:<br>
First, as all we known, there existed 2^n solutions. Then we need to minus the solution that has circles from it. This is a graph with n edges and n vertexs. Actually, it is a circle-based tree. The edges in the circle must point in the same way. Otherwise, it is not a circle.</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://dawn-cmd.github.io/post-images/1612358736984.png" alt="" loading="lazy"></figure>
<p>Other edges' direction are indifferent. Cause it will neither break existed circles, nor add new circles.</p>
<p>Obviously, the illegal number of illegal solutions is 2^(n - len) * 2, len is the length of the circle. Hence, there are (2 ^ len - 2) * 2 ^ (n - len) legal solutions. And we successfully beat the problem ......</p>
<p>Not yet.</p>
<p>The problem didn't mention that the graph is connected. So there may not be only one circle. To each isolated graph, we need to add them all.</p>
<ul>
<li>Code:</li>
</ul>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define MOD ((int)1e9 + 7)
using namespace std;
vector &lt;int&gt; graph[(int)2e5 + 1];
int vis[(int)2e5 + 1];
int dfs(int now, int fa, int depth, int &amp;cnt) {
    if (vis[now] &amp;&amp; vis[fa] == 1) {
        vis[now] += 1;
        return -depth;   
    }
    if (vis[now] &amp;&amp; vis[fa] == 2) {
        return 0;
    }
    if (vis[now] == 2) {
        return 0;
    }
    vis[now] += 1;
    cnt += 1;
    if (graph[now].size() == 1) {
       return 1;
    }
    int ans = 1;
    for (int i = 0, l = graph[now].size(); i &lt; l; ++i) {
         int t = graph[now][i];
         if (t == fa) continue;
         ans += dfs(t, now, depth + 1, cnt);
    }
    return ans;
}
ll qpow(ll x, ll b) {
    if (b == 0) return 1;
    if (b &amp; 1) return x * qpow(x * x % MOD, b &gt;&gt; 1) % MOD;
    else return qpow(x * x % MOD, b &gt;&gt; 1);
}
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i) {
        int tmp;
        cin &gt;&gt; tmp;
        graph[tmp].push_back(i);
        graph[i].push_back(tmp);
    }
    memset(vis, 0, sizeof vis);
    ll ans = 0;
    for (int i = 1; i &lt;= n; ++i) {
        if (vis[i]) {
            continue;
        }
        int cnt = 0;
        int s = dfs(i, -1, 0, cnt);
        ans = (ans + (qpow(2, cnt) - qpow(2, s) * 2 % MOD + MOD) % MOD) % MOD;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deep Analysis: Fancy Sequence]]></title>
        <id>https://dawn-cmd.github.io/post/FYQ2RAKvZ/</id>
        <link href="https://dawn-cmd.github.io/post/FYQ2RAKvZ/">
        </link>
        <updated>2020-12-22T12:46:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="problem-description">Problem Description</h2>
<p>Write an API that generates fancy sequences using the append, addAll, and multAll operations.<br>
Implement the Fancy class:</p>
<ul>
<li>Fancy() Initializes the object with an empty sequence.</li>
<li>void append(val) Appends an integer val to the end of the sequence.</li>
<li>void addAll(inc) Increments all existing values in the sequence by an integer inc.</li>
<li>void multAll(m) Multiplies all existing values in the sequence by an integer m.</li>
<li>int getIndex(idx) Gets the current value at index idx (0-indexed) of the sequence modulo 109 + 7. If the index is greater or equal than the length of the sequence, return -1.</li>
</ul>
<h2 id="constrains">Constrains</h2>
<p>1 &lt;= val, inc, m &lt;= 100<br>
0 &lt;= idx &lt;= 10^5<br>
At most 10^5 calls total will be made to append, addAll, multAll, and getIndex.</p>
<h2 id="solution-1-binary-indexed-tree">Solution 1: Binary Indexed Tree:</h2>
<p>This time, I will not list the violent solution because it is too apperant.  First, we can find that all the operations are add and multiply. This two modifications can add up under a mod. So this problem can be understanded in this way: each add and multiply demand can be seem as a node on a list and each node just affect the numbers before it. So when numbers come in, it will not be affected by previous buffs. When you try to get a specific number in the list, you just add all the previous buffs onto the number.</p>
<p>Obviously, prefix sum can satisfied our needs. So what's the most direct and simple data structure that can achieve prefix sum? Binary Indexed Tree. Because I have already write an article to talk about the realization of Binary Indexed Tree, I will just choose some key points to mention here. The problem is, how to &quot;add&quot; buffs. Can we just add them up simply? Of course not. Let's assume f(x) = ax + b, g(x) = cx + d, and the f + g is a*cx + b * c + d. Although the two functions cannot be reversed, it will not affect the final answer.</p>
<pre><code class="language-python">class Fancy:

    mod = 10 ** 9 + 7

    class expression:  # f(x) = a * x + b
        mod = 10 ** 9 + 7
        def __init__(self, x = 1, y = 0):
            self.a, self.b = x, y
        def __add__(self, other):
            self.a = self.a * other.a % self.mod
            self.b = (self.b * other.a + other.b) % self.mod
            return self

    lowbit = lambda self, x: x &amp; -x

    def __init__(self):
        self.nums = []
        self.c = [self.expression() for _ in range(200000)]

    def doit(self, demand):
        i = 100000 - len(self.nums)
        while i &lt; 200000:
            self.c[i] = self.c[i] + demand
            i += self.lowbit(i)

    def append(self, val: int) -&gt; None:
        self.nums.append(val)

    def addAll(self, inc: int) -&gt; None:
        if len(self.nums) == 0:
            return
        demand = self.expression(1, inc)
        self.doit(demand)

    def multAll(self, m: int) -&gt; None:
        if len(self.nums) == 0:
            return
        demand = self.expression(m, 0)
        self.doit(demand)

    def getIndex(self, idx: int) -&gt; int:
        if idx &gt;= len(self.nums):
            return -1
        op = self.expression()
        i = 100000 - idx - 1
        while i &gt;= 1:
            op = op + self.c[i]
            i -= self.lowbit(i)
        return (self.nums[idx] * op.a % self.mod + op.b) % self.mod
</code></pre>
<h2 id="solution-2-multiplicative-inverse-modulomim">Solution 2: Multiplicative inverse modulo(MIM)</h2>
<p>There also existed a more elegant way to solve the problem. If we just use a and b to record all the behaviour, we just need to minus b and divide a before a number adds into the list. But here comes a question, this minus and divide can not be supported under a mod. So we need to use an MIM. MIM can help us use add and multiply to realize minus and divide under a mod: (x / b) % mod = (b ^ (mod - 2) * x) % mod, x - b = (x + mod - b) % mod.. With the two equations, we can solve the problem easily.</p>
<pre><code class="language-python">class Fancy:

    mult = 1
    add = 0
    mod = 10 ** 9 + 7

    def qpow(self, num, power):
        return 1 if power == 0 else self.qpow(num ** 2 % self.mod, power &gt;&gt; 1) % self.mod * (num if power &amp; 1 == 1 else 1)

    def __init__(self):
        self.val = []

    def append(self, val: int) -&gt; None:
        val = (val - self.add + self.mod) * self.qpow(self.mult, self.mod - 2) % self.mod
        self.val.append(val)

    def addAll(self, inc: int) -&gt; None:
        self.add = (self.add + inc) % self.mod

    def multAll(self, m: int) -&gt; None:
        self.mult = self.mult * m % self.mod
        self.add = self.add * m % self.mod

    def getIndex(self, idx: int) -&gt; int:
        return -1 if idx &gt;= len(self.val) else (self.val[idx] * self.mult % self.mod + self.add) % self.mod 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deep Analysis: Count Primes]]></title>
        <id>https://dawn-cmd.github.io/post/Fo59-fr0V/</id>
        <link href="https://dawn-cmd.github.io/post/Fo59-fr0V/">
        </link>
        <updated>2020-12-03T12:45:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="problem-description">Problem Description</h2>
<p>Count the number of prime numbers less than a non-negative number n.</p>
<h2 id="constraints">Constraints:</h2>
<p>0 &lt;= n &lt;= 5 * 10 ^ 6</p>
<h2 id="solution-1-volent-trying">Solution 1: Volent Trying</h2>
<p>So let's see the algorithm with the worst time efficiency. What we need to do is just identifying the integers are primes or not one by one. In the end, we count the number of primes and return the answer. When judging every number, we need to check whether the number from 2 to n - 1 can divide the number we need to judge. If yes, the number is not a prime and in other cases it is a prime.</p>
<pre><code class="language-python">def isprime(num):
    if num == 0 or num == 1:
        return 0
    i = 2
    while i  &lt; num:
        if num % i == 0:
            return 0
        i += 1
    return 1

def main():
    n = int(input())
    ans = 0
    for i in range(n):
        ans += isprime(i)
    print(ans)

main()
</code></pre>
<h2 id="solution-2-a-little-bit-improvement">Solution 2: A little bit improvement</h2>
<p>Let's focus on the function &quot;isprime&quot;. In this function, we try to use [2, n) to divide the number, but actually, we just need [2, sqrt(n) + 1). Because when we try a number larger than sqrt(n) + 1, this process must be repeated before. So we can get this code.</p>
<pre><code class="language-python">def isprime(num):
    if num == 0 or num == 1:
        return 0
    i = 2
    while i ** 2 &lt;= num:  # I did not import Math because it will make the program slow
        if num % i == 0:
            return 0
        i += 1
    return 1

def main():
    n = int(input())
    ans = 0
    for i in range(n):
        ans += isprime(i)
    print(ans)

main()
</code></pre>
<h2 id="solution-3-another-trick">Solution 3: Another trick</h2>
<p>When you judge a number is a prime or not, 6 is a quite efficient number. Why? Because except 2 and 3, if a number n % 6 is neither 1 nor 5, it must not be a prime: 6k + 2 can divide by 2, 6k + 3 can divide by 3, 6k + 4 can divide by 2, 6k + 6 can divde by 6. As a result, we use just one command to cut 2/3 answers. Why it is not efficient?</p>
<pre><code class="language-python">def isprime(num):
    if num == 0 or num == 1:
        return 0
    if num == 2 or num == 3:
        return 1
    elif num % 6 != 1 and num % 6 != 5:
        return 0
    i = 2
    while i ** 2 &lt;= num:
        if num % i == 0:
            return 0
        i += 1
    return 1

def main():
    n = int(input())
    ans = 0
    for i in range(n):
        ans += isprime(i)
    print(ans)

main()
</code></pre>
<h2 id="solution-4-sieve-of-eratosthenes">Solution 4: Sieve of Eratosthenes</h2>
<p>Up to now, it is quite efficient on judging one prime. But we have to judge n numbers. Does there exist better algorithm or not? Of course yes. The Sieve of Eratosthenes can produce the prime from 2 to n - 1 in one time an it is easy to understand: if k is a prime, then k * 2, k * 3, k * 4...... are not primes.</p>
<pre><code class="language-python">def prime_select():
    n = 5 * (10 ** 6) + 1
    h = [1] * n
    h[1] = h[0] = 0
    for i in range(2, n):
        if h[i] == 0:
            continue
        j = i
        while j * i &lt; n:
            h[i * j] = 0
            j += 1
    return h

h = prime_select()

class Solution:
    
    def countPrimes(self, n: int) -&gt; int:
        ans = 0
        for i in range(n):
            ans += h[i]
        return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deep Analysis: Minimum Number of Arrows to Burst Balloons]]></title>
        <id>https://dawn-cmd.github.io/post/guwS0s3Te/</id>
        <link href="https://dawn-cmd.github.io/post/guwS0s3Te/">
        </link>
        <updated>2020-11-25T12:43:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="problem-description">Problem Description</h2>
<p>There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.</p>
<p>Given an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons.</p>
<h2 id="constraints">Constraints</h2>
<p>0 &lt;= points.length &lt;= 104<br>
points[i].length == 2<br>
-2^31 &lt;= xstart &lt; xend &lt;= 2^31 - 1</p>
<h2 id="solution-1-violent-try">Solution 1: Violent Try</h2>
<p>No algorithms! No data structure! Just try all the possibilities. For         each point on x-axis, it has two conditions: has arrow or not. We can          represent it by 0 and 1. Under the most terrible situation, we have 2^        (2^32) possibilities. But it does not matter at all! Because many             excellent solution, algorithms and data structures starts from it.</p>
<pre><code class="language-python">class Solution:
    ans = 2 ** 32 - 1
    def dfs(self, now, end, h):
        if now == end:
            if check(h):
                ans = min(ans, sum(h))
            return
        self.dfs(now + 1, end, h + [0])
        self.dfs(now + 1, end, h + [1])
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int: 
        start = min(list(map(lambda x: x[0], points)))
        end = max(list(map(lambda x: x[1], points)))
        self.dfs(start, end, [])
        return self.ans
</code></pre>
<h2 id="solution-2-greedy-algorithm">Solution 2: Greedy algorithm</h2>
<p>Obviously, we wasted a lot of arrows in the previous trying. So we will try our best to save our arrows. What we do is still judge it from left or right(reverse is okay), but we only use the arrow when we really need it otherwise we have no chance. Let me explain it, for example, there is a balloon is from 5 to 8, and we find position 8 is the last point in its cover. That is to say if we just let it go, we will not be able to shoot the balloon again. So we use the arrow here.</p>
<pre><code class="language-python">class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        ans += 0 
        for i in range(left, right + 1):
            if i is a balloon's right bound:
                # realize a function to shoot a arrow at x[i]
                ans += 1
        return ans        
</code></pre>
<h2 id="solution-3-a-small-improvement">Solution 3: A small improvement</h2>
<p>Up to now, we have build a prototype of the final solution. Let's see whether there is anything can be improved or not. We find that the loop in the previous code has many superfluous visit to irrevelent positions. Because we can see only at the right bound of a balloon, we may do something and the points between two bounds won't be used at all. Self-evidently, we only need to visit the bound points. What's more, we have to visit it by the sequence of its position on x-axis. So we need to sort them with their right bound positions and visit them.</p>
<pre><code class="language-python">class item:
    
    def __init__(self, start, end):
        self.start, self.end = start, end

    def __lt__(self, other):
        return self.end &lt; other.end

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int: 
        p = []
        for i in range(len(points)):
            p.append(item(points[i][0], points[i][1]))
        p.sort()
        ans = 0
        h = [0] * len(p)
        for i in range(len(p)):
            if h[i] == 1:
                continue
            ans += 1
            for j in range(i, len(p)):
                if h[j] == 1:
                    continue
                elif p[j].start &lt;= p[i].end:
                    h[j] = 1
        return ans
</code></pre>
<h2 id="solution-4-a-large-step-to-the-best-one">Solution 4: A large step to the best one</h2>
<p>The solution 3 is excellent enough in most cases, but it is still not stable. In some special cases, the time complexity of the solution will raise to O(n^2). In some restrictedly developing environments, we need a more stable algorithm. Let's see the line 24: when the computer find that this arrow cannot shoot this ballon, it chooses to continue visiting the rest balloons, but it is not necessary. When we find this arrow cannot shoot a balloon for the first time, we can quit the loop. Why? Because if this arrow cannot shoot the balloon, the other arrows will shoot it later, so the following balloons that this arrow can shoot, the other arrows can do it as well.</p>
<pre><code class="language-python">class item:
    
    def __init__(self, start, end):
        self.start, self.end = start, end

    def __lt__(self, other):
        return self.end &lt; other.end

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int: 
        p = []
        for i in range(len(points)):
            p.append(item(points[i][0], points[i][1]))
        p.sort()
        ans = 0
        h = [0] * len(p)
        for i in range(len(p)):
            if h[i] == 1:
                continue
            ans += 1
            for j in range(i, len(p)):
                if h[j] == 1:
                    continue
                elif p[j].start &lt;= p[i].end:
                    h[j] = 1
                else:
                    break
        return ans
</code></pre>
<h2 id="solution-5-make-it-beautiful">Solution 5: Make it beautiful</h2>
<pre><code class="language-python">class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int: 
        points = sorted(points, key = lambda x: x[1])
        ans = 0
        min_end = -2 ** 31 - 1
        for i in points:
            if i[0] &gt; min_end:
                ans += 1
                min_end = i[1]
        return ans
</code></pre>
]]></content>
    </entry>
</feed>